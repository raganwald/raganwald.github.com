<html> 
<head>
        
        <title>If Sneetches with Stars use Java, and Sneetches without Stars use Ruby, who uses ML?</title>

	<link rel="stylesheet" type="text/css" href="/blog.css" />
	<link rel="stylesheet" type="text/css" href="/sunburst.css" />



	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>

<body>

	<div id="leftcontent">
			<a href="http://raganwald.github.com/"><img src="http://raganwald.github.com/assets/raganwald_2008_350_150" 
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/></a><br/>
			
				<div class="DateHeader">Sunday, October 08, 2006</div>
			

			<div class="Post"><a name="116033648506034653">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html" title="permanent link">If Sneetches with Stars use Java, and Sneetches without Stars use Ruby, who uses ML?</a></span>
					<div style="clear:both;"></div><a href="http://en.wikipedia.org/wiki/ML_programming_language">ML</a> is a programming language featuring <a href="http://en.wikipedia.org/wiki/Type_inference">type inference</a>: you don’t have to encumber your code with type declarations, the compiler can figure them out for you. So… are type inference languages like ML for Sneetches <a href="http://steve-yegge.blogspot.com/2006/10/egomania-itself.html">with or without stars</a>? Or another kind of Sneetch entirely?<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/Sneetches-Other-Stories-Classic-Seuss/dp/0394800893/s?ref=raganwald001-20"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/sneetches-711589.jpg" border="0" alt="" /></a><blockquote style="font-style: italic;">Now, the Star-Belly Sneetches had bellies with stars.<br />The Plain-Belly Sneetches had none upon thars.<br />Those stars weren’t so big. They were really so small<br />You might think such a thing wouldn’t matter at all.</blockquote><span style="font-style: italic;font-size:85%;" >Update</span><span style="font-size:85%;">: More than a few people have <a href="http://empathybox.com/archives/7">written</a> that Steve Yegge's association of static typing with neatness and dynamic typing with slovenliness runs opposite to their impressions of the kinds of people who strongly prefer one or the other. I used Steve's terms in the original post, partly because I thought people would get the same joke I thought Steve was making. It looks like they don't, nobody wrote to say "LOL." I have changed the terms to something that represents what I think of the cultural divide between programmers who like Java and programmers who like Ruby.</span><br /><br />Let’s review. Sneetches with stars like to use a colour-coded label maker to label the drawers, boxes, and files in their office. Once glance at everything and you know what it holds. Sneetches with stars add extra labels even when you don’t need them. For example, if a box is labeled ‘tax receipts’, each piece of paper inside has a post-it note saying tax receipt’, even if it’s obviously a tax receipt and lives inside the tax receipts box.<h4 id="what_is_stariness">What is Stariness?</h4>Sneetches with stars like these languages we say are <em>statically typed</em>. What do we mean by the word static? We mean <em>it can be resolved at compile time</em>. Other words for this idea are <em>invariant</em> or <em>constant</em>. Sneetches with stars like languages where the type of each entity can be resolved at compile time.<br /><blockquote>Some people are always critical of vague statements. I tend rather to be critical of precise statements; they are the only ones which can correctly be labelled "wrong."</blockquote><div style="text-align: right;">Raymond Smullyan<br /></div><br />Let’s dive into this a little deeper. (My apologies to my readers who were actually paying attention to the stuff in first year computer science that isn’t a requirement for <a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">getting a job at BigCo</a>.) What does it mean when we say “something can be resolved at compile time”? That expression is laden with implementation details like assuming we’re using a compiler. But it’s a convenient short-hand for saying <em>something about the program that is true every time you run the program</em>.<br /><br />Consider the <code>final</code> declaration in Java. If you write:<br /><pre><code>final String snafu = "situation normal...";<br /></code></pre>We know that the variable <code>snafu</code> always holds a reference to the constant string <code>"situation normal..."</code>. No matter what data you feed to your program and how you mangle it, <code>snafu</code> will always be <code>"situation normal..."</code>. Do you agree? (Joe Campbell, put your hand down. Yes, there is a back door way you can change the contents of a <code>String</code> in Java.)<br /><br />Java can take advantage of this to perform <em>constant propagation</em>. Everywhere you write <code>snafu</code>, Java can substitute <code>"situation normal..."</code> and throw away the variable lookup. To get away from arguing about back doors in the <code>String</code> class, let’s consider one of the primitive types, a <code>boolean</code>. If you write:<br /><pre><code>final boolean foo = true;<br />    // code without assignments to foo<br />    if (foo) {<br />        // do something<br />    }<br />    else {<br />        // do something else<br />    }<br /></code></pre>Wouldn’t you agree that the compiler can get rid of the variable lookup and the <code>if</code> statement? The path through the code is always through the <code>// do something</code> path every time you run the program.<br /><br />Now back to the word <em>stariness</em>. We really mean <em>the amount of stuff about the program that can be resolved at compile time</em>, or if you prefer, <em>the amount of stuff that is true every time you run the program</em>.<br /><br />In the example above, the compiler can figure out which branch the program will follow at compile time, because that variable is true every time you run the program.<br /><br />Stuff that is always true is useful. For most programs, we have an idea in our head about “correctness.” What we mean when we talk about a program being correct is that it produces desirable results every time you run the program.<br /><blockquote>A formalist is one who cannot understand a theory unless it is meaningless.</blockquote>Stariness is thus similar to correctness. And that’s why a lot of people, the Sneetches with stars, are obsessed with it. Being able to “prove” something about their program (“the method call <code>foo.bar(5)</code> never throws a <code>MethodNotImplemented</code> exception”) feels a lot like being able to prove that their program is correct.<br /><br />It feels a lot like it, but it isn’t the same thing. The reason it isn’t the same thing is that while its true that a program throwing <code>MethodNotImplemented</code> exceptions is probably not correct, it’s not true that a program that doesn’t throw such exceptions <em>is</em> correct. It just feels, somehow, more likely to be correct because we’ve thrown out one of the infinite ways it can be incorrect.<br /><br />Now that we’ve dispatched that logically, let’s be clear about something: just because stariness does not enforce correctness, it doesn’t mean that stariness isn’t <strong>useful</strong>. Stariness is useful. Period, no debate.<h4 id="back_to_inferences">Back to inferences</h4>Type inference is also for Sneetches with stars.  A language with type inference resolves the type of each entity at compile time by inspecting the program and figuring the types out through inspection. It’s a lot like the way a compiler can look at the Java code above and figure out that you always <code>// do something</code> and you never <code>// do something else</code>. The code looks sorta like you could go either way, but the compiler knows better.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FLittle-MLer-Matthias-Felleisen%2Fdp%2F026256114X%2Fsr%3D1-1%2Fqid%3D1165759722%3Fie%3DUTF8%26s%3Dbooks&tag=raganwald-store-20&linkCode=ur2&camp=1789&creative=9325"><img style="float:left; margin:0 10px 10px 0;cursor:pointer; cursor:hand;" src="http://raganwald.github.com/uploaded_images/little_mler-705423.jpg" border="0" alt="" /></a>Languages with type inference look like variables can have any type, but the compiler knows better. Remember the labels that the verbose declaration Sneetches with stars love? Type inference languages still have labels, but the labels are hidden inside of the files and boxes where you can’t see them.<br /><br />Remember when manufacturers used to put their labels <em>inside</em> clothes instead of right across the front? Same thing. The rules for what goes where are strictly enforced, it’s just that if you can figure out what goes where with a bit of common sense, you don’t need a label or a post-it note.<br /><br />Compare these two snippets of Java:<br /><pre><code>final String[] words = { "foo", "bar", "blitz" };<br />final int word_length = words.length;<br />final String[] anagrams = new String[word_length];<br /></code></pre>…and…<br /><pre><code>final words = { "foo", "bar", "blitz" };<br />final word_length = words.length;<br />final anagrams = new String[word_length];<br /></code></pre>Hey, if a variable is final, we can figure out its type in Java through simple inspection. Making that work in the compiler is something an intern ought to be able to do over a Summer work term!<br /><br /><span style="font-size:85%;">(Frank Atanassow pointed out that techniques exist for inferring the types of nearly all Java variables through inspection of programs. But this simple case is enough for our purposes.)</span><br /><br />So if we take a valid Java program and simply erased type declarations whenever we could logically deduce the type of the variables (using our simple scheme), but left them in whenever we were not sure of the final type of the variables, we would have exactly the same program. Nothing about it has changed except it has fewer symbols. It’s just as starry, it is just as static, it is no more or less correct than it was before we erased some symbols.<br /><br />And you over there itching to say something about IDE refactorings and auto-completions: None of those go away either. You can rename things and move things and press command-tab to get an object’s methods whenever you like. So… would you agree that type inference of this sort doesn’t change a starry program into a starless program? This isn’t about stariness versus starlessness, it’s about the obsessive-compulsive desire to label everything.<br /><br />The bottom line: <em>type inference does not change a statically typed language into a dynamically typed language</em>. It’s still starry.<h4 id="so_why_can8217t_the_Sneetches without stars_use_type_inference">So why can’t the Sneetches without stars use type inference?</h4>Think of types as being like values and objects like variables. A statically typed language is one where there are no type re-assignments. Some languages enforce this. But if you write a program in a static way, you can still reason about it. This is why lots of people think that we can “neaten up” languages like Ruby by adding type inference to the compiler: they're thinking about programs that are neat to begin with, but we happen to have written them in a language for Sneetches without stars.<br /><br />And whenever someone talks about a refactoring IDE or an auto-completing IDE for a dynamic language, they’re talking about performing some type inference on Ruby programs that are written in a static way. So… what’s the holdup? We said we could add type inference to Java in a Summer. Where’s the intern to add it to Ruby?<br /><blockquote>Programmed. In me somewhere, he thought, there is a matrix fitted in place, a grid screen that cuts me off from certain thoughts, certain actions. And forces me into others. I am not free. I never was, but now I know that; that makes it different.</blockquote><div style="text-align: right;">Philip K. Dick, "The Electric Ant"<br /></div><br />The problem is that the set of all programs that are "starry" is a subset of the set of all programs that parse correctly. So either not all starless programs are neat, or not all portions of a starless program are neat, or both.<br /><br />Let’s compare back to our Java snippet. Remember:<br /><pre><code>final boolean foo = true;<br />// code without assignments to foo<br />if (foo) {<br />    // do something<br />}<br />else {<br />    // do something else<br />}<br /></code></pre>The compiler could infer that we always follow the first branch because it knows that final variables are not reassigned. They’re <em>immutable</em>. What happens if we erase the <code>final</code> keyword as well:<br /><pre><code>boolean foo = true;<br />// code that might have assignments to foo<br />if (foo) {<br />    // do something<br />}<br />else {<br />    // do something else<br />}<br /></code></pre>Now the job is much harder. We have to examine all the code in between the declaration and the use of foo. If there are any assignments involving things we can't know until runtime, we can't know the value of foo until runtime.<br /><br />For a very large class of programs, we cannot infer the contents of a variable with less runtime complexity than running the program for every possible input. This is why compilers have limitations on the optimizations they can perform, and humans still need to do some thinking about writing fast programs.<br /><br />This exact same thing happens with types. In statically typed languages, types are never re-assigned. Whether explicitly declared or inferred, they're immutable. But in languages like Ruby where methods can be added and removed dynamically, where messages can be forwarded dynamically, where we can even send messages dynamically, the types of objects are fully mutable.<br /><br />In starless languges, there is no <code>final</code> keyword on the types of objects. We can no longer infer the type of a variable in any but the simplest, degenerate cases.<br /><br />The type inference problem in dynamically typed languages is exactly the same as the inferring the possible contents of a variable problem. The inferring the contents of a variable problem is doable for a restricted set of programs. And the way we tell the compiler that a variable is a member of this restricted set is with the <code>final</code> keyword.<br /><br />Likewise, the way we tell a compiler that the type of a variable is also restricted is that we use a language where the type of every variable is final. It’s the same thing: we don’t reassign final variables and we don’t change types on the fly.<br /><br />Starlessness is not about writing programs without labels. Starlessness is when you write dynamic programs. Dynamic doesn’t mean ‘unlabeled’. As I showed above, if the <code>final</code> keyword is there, the label is mostly optional. But if you don’t have <code>final</code>, you’re writing dynamic programs.<br /><br />Truly starless programs have dynamic types: <em>types that change at run time</em>. they are not always one thing or another. For example, what if you write an Object-Relational Mapper (“ORM”) that reflects on the database structure at run time. That is, you can change columns in a database table and you get new getters and setter methods in your program. <em>Without recompiling</em>.<br /><br />In a fully static language (with or without type inference), you can’t do that. Think of Java’s JDBC: you have to fool around with methods that get values and pass a column name as a parameter. Or maybe you create a hash. And C# is getting this capability, but of you look closely you still have to define the “type” of a query through the LINQ syntax.<h4 id="are_neat_freaks_ever_starless">Are Sneetches with stars ever starless?</h4>A dynamically typed language lets us define an object holding a database row with methods for each column. But we can’t know at compile time whether our program will throw a <code>MethodNotImplemented</code> exception because we don’t know whether someone will monkey with the database structure. That sounds bad.<br /><br />But what happens if you write the same thing in a neat program? Aha! a <code>SQLException</code>! it seems that there are dynamic things that must be dynamic no matter what you do.<br /><br />This is a specific case of Greenspunning. There are some facilities of dynamic languages that you are going to need. If you don’t have them built into your static language, you will build them yourself or use a framework that has already built them for you. Other examples I have seen in Java programs include:<br /><br />Spring and Hibernate;<br />Any use of <code>Class.forName(...)</code>;<br />Any use of dynamic proxies;<br /><br />In essence, you’re being a Sneetch without a star but twisting your starry language to permit starlessness. And for those portions of the program that are no longer nice, starry bundles that can be examined at compile time for invariant behaviour, you are indeed in dynamic territory and have to live with the risks.<br /><br />In my experience, all non-trivial starry programs contain this kind of starlessness. To my admittedly inexperienced eyes, starlessness is the hallmark of expert programming in starry languages ("expert" does not necessarily mean "more desirable," especially in the minds of those who believe that programs should be written and maintained by mediocre developers).<h4 id="eating_cake">Eating cake</h4>So… can we say that since you can write starless programs in neat languages, you can have the useful benefits of stariness when you need it and the flexibility of starlessness when you need that too? Isn’t that better?<br /><br />Yes, you <em>can</em> say that. And you may be right, for you. The <a href="http://boo.codehaus.org/Language+Guide">Boo</a> people believe that: their language has a <code>duck</code> keyword for when you feel like a Sneetch without a star. Be aware that at this moment in history, languages designed for Sneetches without stars seem to have much better features for writing starless programs than languages for Sneetches with stars. So my observation is this:<br /><br /><em>If you dislike the verbosity of starry languages like Java but like the feeling of safety, try a type inference language. Don’t go to a starless language if you don’t intend to actually write dynamically typed programs.</em><br /><br />My experience is that if you are frustrated by the amount of work you have to do to express the algorithms in your head, you should look at a language that removes your frustration. If you're using Java and don't like the verbosity, find a language that celebrates brevity while preserving static typing. But if you're using Java and find yourself pushing more and more logic out of java because its type system is too static or too inflexible, you should consider a language with a different approach to typing.<br /><blockquote>Computer languages differ not so much in what they make possible, but in what they make easy. </blockquote><div style="text-align: right;">Larry Wall<br /></div><h4 id="why_would_the_Sneetches without stars_use_starless_languages">Why would the Sneetches without stars use starless languages?</h4><em>Writing starless programs on top of neat languages is exactly the same thing as writing automatic memory management routines on top of a manually managed programming language or writing functional programs on top of a noun-centric object-oriented language.</em><br /><br />You can take that statement as an argument in favour of specialized languages for Sneetches without stars or as an argument against them. My guess is that the above statement is true and a Rorschach Inkblot: You will interpret it as confirmation of your existing prejudices.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/labels/java.html">java</a>, <a rel='tag' href="http://raganwald.github.com/labels/popular.html">popular</a>, <a rel='tag' href="http://raganwald.github.com/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html" title="permanent link">3:34 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			
			    <div class="blogComments">
                                
                                <a name="comments"></a><strong>Comments on &ldquo;<em>If Sneetches with Stars use Java, and Sneetches without Stars use Ruby, who uses ML?</em>&rdquo;</strong>:<br/>
						
							<div class="blogComment">
								<a name="116034788736063333"></a> 				There are big "yes but" to using inference typing.<BR/><BR/>first, mixing inference with side effects is complicated O'caml weak types are a sample of this complexity. For example 2 programs with the same value denotation might not denote the same type.<BR/><BR/>second, inference typing leads to complicated (meaningful) error reporting. If I remeber well, Xavier Leroy himself told that useful error reporting is a matter of research by itself.<BR/><BR/>Remember : there is no silver bullets, only compromises and trends.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1160347860000#c116034788736063333" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">nraynaud</span> : 6:51 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116034788736063333" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116034867053918206"></a> 				<I>If Neat Freaks use Java, and Slobs use Ruby...</I><BR/>A fallacy - so we need read no further.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1160348640000#c116034867053918206" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/05398229396333413000" rel="nofollow">Isaac Gouy</a> : 7:04 PM</div>

								<span class="item-control blog-admin pid-51843297"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116034867053918206" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116036048819956417"></a> 				I don’t know how something that fails to make the proper Foleyesque slobering noises about dynamic typing and Ruby on Rails managed to get voted up on reddit, but I am glad this did. It is a rather excellent article that manages to nail the issue without really taking sides. My only complaint is this: it gets the recommendation exactly wrong.<BR/><BR/>If you use a slobby language like python you will have to become extremely neat. If you work on a project with more than one programmer you will have to start documenting the types of every function in comments or you you will find yourself having discussions like “fred, does this method expect a list of hashes that map ints to strings, or a list of hashes that map ints to user objects?”. You will also have to be very serious about your testing strategy to make sure that you maintain the ability to refactor when you have a lot of code, otherwise it is impossible to know when you have broken something. If you have only 60% unit test coverage in some area, you will need to do a lot of manual testing to ensure you haven’t broken something with your refactoring.<BR/><BR/>Likewise if you work in a language where the compiler checks your types for you, you can be a lot sloppier. You can make interface changes and depend on the compiler (or a refactoring tool) to find all the various places you have just broken.<BR/><BR/>One should pick tools that correct ones own tendencies (or those of your team), not tools that exacerbate problems.  It may be that dynamic types appeal to slobs, but that does not mean that dynamic types are good for slobs.<BR/><BR/>So my recommendation would be this: if you are very precise about types, so much so that you can maintain them all in your head, then dynamic languages are the way to go–they will offer you flexibility and less writing out of types. If you find yourself slipping a bit in your precision, then you want a compiler which checks static types for you. I know that I am a slob, so I think that type inference is in my future.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1160360460000#c116036048819956417" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<a href="http://empathybox.com/" rel="nofollow">jay</a> : 10:21 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116036048819956417" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116036485101527467"></a> 				Jay:<BR/><BR/>I appreciate your arguments, and I agree with you rrecommendations.<BR/><BR/>That being said, I think they are orthogonal to my own recommendation, which is to use a statically typed language if your types never change.<BR/><BR/>'Slovenly languages' aren't really for people who are careless, but rather they are for people who sometimes do one thing with a variable, and sometimes another.<BR/><BR/>In my own case, one of the things I regularly do with Ruby is extend pre-existing types with new functionality.<BR/><BR/>This is a big no-no with the neatness crowd. This is why Java really permits you to mark a class final: so that other programmers cannot extend it.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1160364840000#c116036485101527467" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 11:34 PM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116036485101527467" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116036500455474185"></a> 				nreynaud:<BR/><BR/><I>There are big "yes but" to using inference typing.</I><BR/><BR/>Your point about error reporting is particularly salient.<BR/><BR/>As to silver bullets, Wasabi... oh never mind, I <A HREF="http://raganwald.github.com/2006/09/wasabi-cannot-cure-rotten-fish.html" REL="nofollow">said that already</A>.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1160364960000#c116036500455474185" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 11:36 PM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116036500455474185" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116036508918653437"></a> 				Isaac:<BR/><BR/>Thanks, and I would say that is a static property of this blog.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1160365080000#c116036508918653437" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 11:38 PM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116036508918653437" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116038351190351254"></a> 				Me thinks me would go insane trying to write monadic code in Haskell without type inference.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1160383500000#c116038351190351254" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Johan Tibell</span> : 4:45 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116038351190351254" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116041006788322500"></a> 				Correctness is the killer app, it saves me from errors. But we're not there yet.<BR/><BR/>The problem with correctness is that it doesn't scale well. Languages that come from the academic world (things ending with calculus) have correctness, but are very hard to work with for sizeable problems. Java attacked this for small, single purpose applications for handheld devices, but the language didn't scale to handle the problems we're solving today. Ruby and other dynamic languages are worse at correctness, but they have less code to prove.<BR/><BR/>Meta-programming, like frameworks, APIs and constructs before, simply move the correctness to a place where it's easier to prove. Easier just because you have more people looking at it (the brute force approach). So if I have to judge for correctness, I think they're all equally bad, or equally good, depending on the half of the glass.<BR/><BR/>I open up a lot of code for access through remote APIs, the moment I start worrying about operations and types that are not enforced by the language, is the moment I stop caring about Java-like correctness. I just want to write less code, so it's easier to prove.<BR/><BR/>Neatness is separate from correctness, it's our need to keep the cognitive load minimal. I don't think Java is more neat than Ruby (or the other way around), they're just neat in different ways. Verbosity is neatness for some, a big mess for others.<BR/><BR/>And then, there's status quo ...<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1160410020000#c116041006788322500" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<a href="http://labnotes.org" rel="nofollow">assaf</a> : 12:07 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116041006788322500" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116049562989493303"></a> 				I liked the original title better. It was catchy and fun.<BR/><BR/>And I don't agree with it, but so what?<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1160495580000#c116049562989493303" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<a href="http://labnotes.org" rel="nofollow">assaf</a> : 11:53 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116049562989493303" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116050599039391963"></a> 				One of the latest and greatest <A HREF="http://cableorganizer.com/label-printer/" REL="nofollow">label makers</A> I've been using is the new K-Sun. It connects to your PC, can print graphics, bar-codes, etc., and can print on a variety of labels. I love it!<BR/><BR/>--Reggie<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1160505960000#c116050599039391963" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/15874317618210813205" rel="nofollow">Reggie Bard</a> : 2:46 PM</div>

								<span class="item-control blog-admin pid-177319857"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116050599039391963" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116058826271248839"></a> 				Jay wrote: <I>if you work in a language where the compiler checks your types for you, you can be a lot sloppier.</I><BR/><BR/>This kind of thinking really, really pisses me off. I'm not one to rant in other people's blogs, so I'll try to say this politely.<BR/><BR/>Why do we think that if we use a smart language, we can write willfully stupid code?<BR/><BR/>Maybe I'm getting crotchety in my old age, but I'm starting to think that every programmer should be locked in a cage with ten other programmers, and forced to team code in ruby, python or perl until they learn to write, document and test code responsibly.<BR/><BR/>I'm a big believer in not trying to do thinking about things that the machine could be thinking about for you. But people, please! Correctness isn't one of those things!<BR/><BR/>Learn to code neatly, responsibly. Or I will hunt you down and beat you until your checksum changes.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1160588220000#c116058826271248839" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/02574521937449887649" rel="nofollow">Chalain</a> : 1:37 PM</div>

								<span class="item-control blog-admin pid-1334674507"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116058826271248839" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116082287156593469"></a> 				<I>This kind of thinking really, really pisses me off. I'm not one to rant in other people's blogs, so I'll try to say this politely.<BR/><BR/>Why do we think that if we use a smart language, we can write willfully stupid code?</I><BR/><BR/>Jay really just reinforces the notion of "neatness". As you might have noticed the same argument pattern applies to defenders of manual vs. those of automatic memory management. The former complain about the carelessness of the latter while those argue with the neatness of their language and a decreasing bug rate. Apparently the use of the "neatness" argument is quite relative.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1160822820000#c116082287156593469" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">schluehk</span> : 6:47 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116082287156593469" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116103077288820550"></a> 				Re error reporting and type inference, there are a couple solutions.<BR/><BR/>A typical implementation of Hindley-Milner unifies on the fly, as it works through the program. That means that it may only find a conflict (no unifier) very far from the source of the error. However, it is possible to do the inference in two passes, first collecting the constraints, and only then solving the web of constraints. It then becomes possible to tell the user where exactly the conflicting constraints were found (or minimal sets of conflicting constraints).<BR/><BR/>As we move to more complex and expressive type systems complete type inference becomes intractable. We need to annotate programs with some declarations. We can then either extend HM with local type inference, or only rely on local inference. If we only rely on local type inference, errors should become clearer, since it's, well, local :) Of course, annotating programs, even with normal HM-style type inference helps since it'll tend to find conflicts earlier.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1161030720000#c116103077288820550" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<a href="http://www.pvk.ca" rel="nofollow">Paul Khuong</a> : 4:32 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116103077288820550" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116137861597996431"></a> 				Contrary to what you suggest (or rather, speculate), immutability has little or nothing to do with the complexity or feasibility of the type inference problem, at least in the context of Java without "generics" (parametric polymorphism).  It is not hard to see why: assignment in Java preserves types.  Witness ML: it has assignment, yet it supports type inference.  The additional issue of variance and subtyping in Java  is trivial to deal with.<BR/><BR/>The tricky issues in type inference have to do with higher-order functions, more sophisticated forms of polymorphism, and sometimes other features like exceptions.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1161378600000#c116137861597996431" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Frank Atanassow</span> : 5:10 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116137861597996431" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116140485484311083"></a> 				Frank:<BR/><BR/><EM>immutability has little or nothing to do with the complexity or feasibility of the type inference problem, at least in the context of Java without “generics” (parametric polymorphism). It is not hard to see why: assignment in Java preserves types.</EM><BR/><BR/>I agree with this, and that wasn’t what I was suggesting. Now that I look at that section, I see that I was muddling two separate arguments I was making. I will edit that section shortly. What I was trying to say is that mutability of <EM>types</EM> in languages like Ruby is congruent to mutability of variables in languages like Java. I should have returned to the discussion of branch optimization.<BR/><BR/>Types in Java work just like final variables: it is very easy to reason about them precisely because they are preserved through the program’s execution. Whereas the dynamic types in Ruby are just like mutable variables in every language: reasoning about their values is extremely hard in all but the most degenerate edge cases.<BR/><BR/>For example, Ruby permits you to assign arbitrary modules to an object, add arbitrary methods, and even remove existing methods at run time. On <EM>any</EM> class or single object. The consensus on Lambda the Ultimate is that in the general case, type inference is undecidable in Ruby.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1161404820000#c116140485484311083" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 12:27 AM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116140485484311083" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116299398783396185"></a> 				<I>the dynamic types in Ruby are just like mutable variables in every language: reasoning about their values is extremely hard in all but the most degenerate edge cases.</I><BR/><BR/>First, I would like to point out that the phrase "reasoning...is extremely hard" is not a recipe for a good programming language, and anyone who simultaneously agrees with that phrase and advocates dynamic typing had better reconsider their own beliefs.<BR/><BR/>Second, I wouldn't compare Ruby's notion of "type" with a mutable variable.  I would compare it with a program property, or (what is the same thing) a collection of values satisfying that property.<BR/><BR/>The notion of "type" in ML and Java is more sophisticated; it's not just a program property in some arbitrary metalanguage, but a syntactic representation of that property in the object language itself, which can be computed with and exploited.<BR/><BR/><I> The consensus on Lambda the Ultimate is that in the general case, type inference is undecidable in Ruby.</I><BR/><BR/>There is no need for consensus.  Ruby is an untyped Turing-complete language.  Therefore, ML-style type inference for Ruby is undecidable.  QED<BR/><BR/>BTW, nraynaud way above wrote:<BR/><BR/><I>mixing inference with side effects is complicated O'caml weak types are a sample of this complexity.</I><BR/><BR/>Problems like weak types arise from the interaction of side effects with parametric polymorphism, so unless we are talking about Java 5, the issue is moot.<BR/><BR/><I>inference typing leads to complicated (meaningful) error reporting. If I remeber well, Xavier Leroy himself told that useful error reporting is a matter of research by itself.</I><BR/><BR/>It's bizarre that you cite this as a defect.  Even the world's most uninformative error report is to be preferred over silently letting the error pass.  (Anyay, inference and type annotation are not mutually exclusive.)<BR/><BR/><I>Remember : there is no silver bullets, only compromises and trends.</I><BR/><BR/>Dogma.  The more information I have about my programs, the better.  If you choose to ignore it, that is your privilege.  But, unless they have a degree in type theory (and even then... we all make mistakes), I prefer to trust an automated analysis of my program over a human's.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1162993980000#c116299398783396185" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Frank Atanassow</span> : 8:53 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116299398783396185" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="116300292702188621"></a> 				Frank:<BR/><BR/>Thanks for returning with some fresh insights to share.<BR/><BR/><I>I would like to point out that the phrase "reasoning...is extremely hard" is not a recipe for a good programming language, and anyone who simultaneously agrees with that phrase and advocates dynamic typing had better reconsider their own beliefs.</I><BR/><BR/>If I understand you, you are saying that proposition A is "for any language L, if L has a feature F where reasoning about the properties of F from examination of the program alone is hard, then L is not a good programming language."<BR/><BR/>And further you are saying that proposition B is "dynamic meta-programming is a useful feature of a programming language."<BR/><BR/>So anyone who simultaneously advocates A and B is in conflict, since the two seem mutually exclusive.<BR/><BR/>Well, if everything in the world were so cut and dried, I would simply suggest that I don't agree with A, or I would suggest that A is not exclusively true or exclusively false in this universe.<BR/><BR/>As an example, I would hold out mutable variables. Programming languages with mutable variables are hard to reason about.<BR/><BR/>Sure, with static type systems we can reason about their types. But not their contents, and thus we have the halting problem and we have bugs and all sorts of folderol that would go away if we stuck to purely functional languages.<BR/><BR/>Nevertheless, people build all sorts of useful software with programming languages that contain the "hard to reason about" feature of mutable variables.<BR/><BR/>The purist in me agrees that such languages may be "less good" than purely functional languages in this narrow area.<BR/><BR/>But when you say "feature F is not a part of a good language," remember that there are many such features, and every language I have examined contains at least one such feature.<BR/><BR/>Most popular languages feature static typing. So they eliminate the "dynamic meta-programming problem." But most of them do not support functions as first-class values, a serious defect in my own opinion. So do we eliminate them from consideration?<BR/><BR/>I would suggest that the design of programming languages is an exercise in compromises, and the language you prefer will be driven by the degree to which you can live with its faults.<BR/><BR/>Finally, I will suggest that the ability to reason about types is useful and good. However, no substantial, real-world program will every be free of some dynamic typing regardless of the programming language used.<BR/><BR/>As I suggested in the post, real world problems are dynamic in nature, and if the language does not directly support dynamism, programmers will build it themselves, greenspunning it.<BR/><BR/>This doesn't mean that dynamic languages are necessarily superior to static languages, just that it is wrong to think that a static language eliminates all uncertainty from programs.<br />
								<div class="byline"><a href="http://raganwald.github.com/2006/10/if-sneetches-with-stars-use-java-and.html?showComment=1163002920000#c116300292702188621" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 11:22 AM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=116300292702188621" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
						
					  
					<br /> <p id="postfeeds"></p> <br />
					

					<br /> <br />
					<a href="http://raganwald.github.com/index.html">&lt;&lt; Home</a>
				</div>

			

		


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://reginald.braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://raganwald.com/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://raganwald.com/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://raganwald.com/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://raganwald.com/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://raganwald.com/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://raganwald.github.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://raganwald.github.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://raganwald.github.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://raganwald.github.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://raganwald.github.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



		<div class="SideBarTitle">Management</div>

		<a href="http://raganwald.github.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://raganwald.github.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://raganwald.github.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://raganwald.github.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://raganwald.github.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://raganwald.github.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://raganwald.github.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://raganwald.github.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://raganwald.github.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://raganwald.github.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://raganwald.github.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://raganwald.github.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://raganwald.github.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://raganwald.github.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://raganwald.github.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://raganwald.github.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_07_01_archive.html">07/08</a> /
		
		
		<br/></p>
		<br/>

		

	</div>





	<div style="visibility: hidden">
		
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>
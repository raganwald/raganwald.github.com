<html> 
<head>
        
        <title>The best question asked this week: What, exactly, are you trying to prove?</title>

	<link rel="stylesheet" type="text/css" href="/blog.css" />
	<link rel="stylesheet" type="text/css" href="/sunburst.css" />



	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>

<body>

	<div id="leftcontent">
			<a href="http://raganwald.github.com/"><img src="http://minus.com/loSY4FTZKVCwz"
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/></a><br/>
			
				<div class="DateHeader">Sunday, November 18, 2007</div>
			

			<div class="Post"><a name="3832618036338053365">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html" title="permanent link">The best question asked this week: What, exactly, are you trying to prove?</a></span>
					<div style="clear:both;"></div><blockquote>To prove the correctness of code, you need to know exactly what correct behavior is for the code, i.e. a complete and unambiguous specification for what the code should do. So tell me dear reader, when was the last time you received an unambiguous fully detailed specification of an application?<br /><br />If I ever received such a thing, I would simply execute that sucker, because the only unambiguous complete spec for what an application does is code. Even then, you have to ask, <strong>how do you prove that the specification does what the customers want?</strong></blockquote><div>&mdash;Phil Haack, <a href="http://haacked.com/archive/2007/11/16/what-exactly-are-you-trying-to-prove.aspx">What Exactly Are You Trying To Prove?</a></div><br />Proving that the software meets the rigorous specification written by the customer before they had seen the software work, before they had tried it, has been of secondary importance to me in my career. The overarching concern has been the transformation of the requirements from what the customer <em>guessed</em> they might need, based on superficial desires and buzzwords, into what the customer <em>discovered</em> was actually important, over the lifetime of the project.<br /><br /><blockquote>No, no, no! You don&rsquo;t know what you want!</blockquote><div>&mdash;Luigi, <a href="http://www.imdb.com/title/tt0317219/quotes">Cars</a></div><br />Hey, I am not blaming customers. They don&rsquo;t know what they want because <em>nobody</em> really knows what the optimum finished software looks like before development begins. Not the Customer, not the Developers, and not even the &ldquo;Architects,&rdquo; &ldquo;Product Managers,&rdquo; &ldquo;Business Analysts&rdquo; or anybody else who think they are a requirements expert.<br /><br />Software development is a process of discovery, for the customer, for management, and for development. As information is acquired&mdash;through inquiry, inspection, or experience gained from misadventure&mdash;our understanding of what we are trying to accomplish is refined. In that respect, every tool, be it a programming language, a development process, or a testing practice, must be judged for its contribution to the <em>transformation</em> of both the requirements and the software over time.<br /><br />I am not saying that <a href="http://raganwald.github.com/2007/07/can-your-type-checking-system-do-this.html" title="Can your type checking system do this?">strong typing</a> or provability, <a href="http://raganwald.github.com/2004/07/requirements-changes-and-acceptance.html" title="Requirements Changes and Acceptance Debt">iterative development</a> or BDD, or anything else is necessarily better or worse in this respect. I am just pointing out that the surface, buzzwords for these things&mdash;fewer bugs, provability, test coverage, separation of concerns&mdash;are not the goal, they are ways and means of achieving the goal, which is the discovery of the true requirements and the delivery of working software which meets the true requirements over the project&rsquo;s complete span.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html" title="permanent link">1:34 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			
			    <div class="blogComments">
                                
                                <a name="comments"></a><strong>Comments on &ldquo;<em>The best question asked this week: What, exactly, are you trying to prove?</em>&rdquo;</strong>:<br/>
						
							<div class="blogComment">
								<a name="67257883755758279"></a> 				Most software I've worked on has user-visible parts that change rapidly while customers change what they want, but also fully internal parts that change very slowly.  Examples would be a messaging layer, or a persistence layer, or maybe some core algorithm.  While it's pretty much impossible to rigorously specify in full how the user-visible parts should work, it is much more possible to do so for the internal facilities.<BR/><BR/>For example, proving that Google Reader is "correct" is probably meaningless, and even if it wasn't, the definition of correct changes so rapidly that it would be an exercise in futility.  But, it may be possible to prove that Google Reader's Atom parser correctly parses feeds in accordance with the standard.<BR/><BR/>That being said, I think trying to "prove" code is correct is still only a fun game for academics.  In the real world we have to settle for heuristics, like unit tests or maybe code coverage.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195420500000#c67257883755758279" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<a href="http://minutillo.com/steve/weblog/" rel="nofollow">steve minutillo</a> : 4:15 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=67257883755758279" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="2843556419488152150"></a> 				As you say, proving that a parser satisfies a spec sounds useful. It's not the most convincing use case I can think of, though. Once you write a correct parser, you're basically done until the spec changes, and the parser might be not much more fundamentally complicated than the spec is. Not so for optimizing compilers (aka the Compiler Writers Full Employment Theorem). If in practice you are going to be tempted to make a growing optimizing compiler or a growing number of variants or both, having an automatic technique to relate their correctness to a fixed-size spec could be rather useful.<BR/><BR/>Unfortunately there are also other serious limitations to proving programs in practice. E.g., it can be difficult to construct proofs of things as complicated as practical programs, and to put proofs in such a pedantically exact form that a machine can check them. Even pushing simple mathematical theorems through a prover like Coq can be fairly tricky. <BR/><BR/>The circuit design folk face the same fundamental problems: "but there might be a bug in the spec" and "a SMOP can be even larger and more complicated when P means Proof than when P means program." In practice, though, for some useful fraction of their designs they can just beat the proof problem to death with techniques like binary decision diagrams. I don't know of any important subfield of software engineering where similarly useful progress has been made, so today in software proof does seem to be only a fun game for academics. But BDDs are a fairly simple trick, and as I understand it, their effectiveness in practice came as an great surprise to most people. So just because proof remains an academic game for a given subfield in year Y doesn't give me complete confidence it will remain an academic game in year Y+4.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195425240000#c2843556419488152150" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/14336821309402794016" rel="nofollow">William Newman</a> : 5:34 PM</div>

								<span class="item-control blog-admin pid-695432826"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=2843556419488152150" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="6350997012564319692"></a> 				There is validation and there is verification or as commonly known to most software engineer as the V&V method.<BR/>Verification is about making sure you might the product right. This involves unit test, integration tests, etc<BR/>Validation is about making sure you make the right product. This involves demonstration, white box testing, testing to specification.<BR/>If you don't know what exactly you are trying to prove, chances are you have no idea what you are building.<BR/>All your process of discovery should be completed before you start development otherwise you don't understand the problem statement. <BR/>Yes there are iterative approach but this only happens once you are using a build plan, that is delivering product phase by phase. At each delivery, you consult your customer, change your requirement, and your validation test plan.<BR/>In addition, you need to actually agree with your customer on some common terms and remove ambiguity. Things like "fast", "correct" are extremely rubbish and subjective. Sit down and learn actually software quality metrics that the industry use to measure quality.<BR/>In the real world, if you actually apply half of what you learn from university and colleges, there would be less projects that run late or cancelled<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195472700000#c6350997012564319692" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Anonymous</span> : 6:45 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=6350997012564319692" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="4299997103706738324"></a> 				Good point. I think technology isn't that important: 90% of failed projects were already doomed by the time the spec landed at the developers.<BR/><BR/>I think the main reason is that software design is like soccer: everybody thinks they know how to do it right. Just like when the guy who is paid $30K a year to repair cars claims to know how that kick should have been caught better than the goalie is paid $3M a year to do just that, users, managers, all sorts of laypeople start their change requests like "Could we add a button that..."<BR/><BR/>This is the hardest part of the job to convince people they should not design software, because they cannot, just stick to defining the expected results.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195473420000#c4299997103706738324" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Miklos Hollender</span> : 6:57 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=4299997103706738324" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="6070391974143113491"></a> 				For many, doing the software development isn't the hard part. <BR/><BR/>Understanding the needs (especially the usually scant "requirements" provided) for the initial development is a big challenge.<BR/><BR/>Even after fully tested, user-validated, and signed off by the users, an ongoing challenge is identifying or interpreting additional system changes requested and properly what it will take to implement the changes without causing problems immediately or down the line.<BR/><BR/>Success isn't the software - it is in the product and how successful it is lies in the hands of the users. Incorrectly understood (and thefore incorrectly applied) requirements will and usually do cause all kinds of problems, sometimes way into the future.<BR/><BR/>I've never been much for all the buzzwords, nor have any manager I have worked for/under either. I guess that has been a good thing :)<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195479120000#c6070391974143113491" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<a href="http://conservativgeek.wordpress.com" rel="nofollow">Chris</a> : 8:32 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=6070391974143113491" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="3802432218329218496"></a> 				Have you read any literature on program verification?  Dijkstra's "A Discipline of Programming" introduces the topic well.<BR/><BR/>This particular criticism is neither novel nor insightful.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195498800000#c3802432218329218496" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Anonymous</span> : 2:00 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=3802432218329218496" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="1442955517470794336"></a> 				Nothing in my remarks here should be construed as critical of program verification.<BR/><BR/>Thank you for making it obvious that my writing does not seem to communicate my intent as clearly as it could.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195509300000#c1442955517470794336" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 4:55 PM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=1442955517470794336" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="8202052180287284190"></a> 				In the same (quoted) paragraph this guy is talking about two distinct things.<BR/><BR/><I><BR/>To prove the correctness of code, you need to know exactly what correct behavior is for the code, i.e. a complete and unambiguous specification for what the code should do.<BR/></I><BR/><BR/>Discusses the correctness of code. "Code", as it is used here, can mean anything from a measly little if statement to the source of a full-blown desktop environment.<BR/><BR/>With monumental amounts of time, effort, and unambiguous specification you probably could prove that a desktop environment functions correctly according to the specs. That said, with much more reasonable amounts of time, effort, and specification you can prove things about <I>portions</I> of a desktop environment. Like, for instance, that the window manager <A HREF="http://programming.reddit.com/info/60x8m/comments/c02hv0g" REL="nofollow">can never lose focus</A>.<BR/><BR/>The following sentence:<BR/><I><BR/>So tell me dear reader, when was the last time you received an unambiguous fully detailed specification of an application?<BR/></I><BR/><BR/>Is talking about an application. Of course when we get to something as large and ill-defined as an application correctness proofs won't be much help. Most people that use them will readily agree with this.<BR/><BR/>The value of proving that code is correct is in plugging all of the leaks in the abstraction. I can write code that works with the xmonad window manager with the assurance that xmonad will never ever ever cause focus issues.<BR/><BR/>Proving code to be correct makes it possible to interact with it under the assumption that it just works. If statements just work, while loops just work, and proven correct window managers just work. Forget about the details, get on with attempting to decipher the rest of the application's requirements, these bits of code will never cause you a problem.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195509480000#c8202052180287284190" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/11581996527740516702" rel="nofollow">Adam Jones</a> : 4:58 PM</div>

								<span class="item-control blog-admin pid-1379805688"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=8202052180287284190" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="700524667412953916"></a> 				As anonymous#6, I apologize if I've misunderstood your post.<BR/><BR/>The question itself is good.  I found the original author's tone derisive and dismissive.<BR/><BR/>Unfortunately, the long-running debate history about program verification has produced a number of throwaway criticisms.  "Euler's proofs were flawed" is one.  "What are you going to prove?" is another.<BR/><BR/>If you strip away the historical baggage, the question itself is interesting.  I would say that any introduction to formal verification should address it.<BR/><BR/>The real answer is that you should begin by selecting a a useful property, breaking it down into several smaller ones and formulating a predicates that describes these.  It may well be that within a program, any invocation of function foo() must not occur between calls to function bar() and baz().<BR/><BR/>Formal verification must apply from the bottom-up (as verifications need to rest on a base of more elemental verifications).  The application then benefits not from improvements to its totality (I would not try to formulate the predicate "This program produces pleasing poetry") but from control of and confidence in its skeleton (that it is free from deadlock, that it has no more than N files open simultaneously).<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195514820000#c700524667412953916" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Anonymous</span> : 6:27 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=700524667412953916" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="1170527497548541502"></a> 				<I>As anonymous#6, I apologize if I've misunderstood your post.</I><BR/><BR/>You are not a number. You are a free (wo)man!<BR/><BR/>Seriously, no need to apologise, although since you did, thank you for the civility.<BR/><BR/>I don't have much of an expectation from comments, other than they are obviously more freewheeling and less formal than my writing things on my blog or people responding on their own blogs.<BR/><BR/>So there is, IMO, a little license to say what you mean as directly as you please.<BR/><BR/>It has provoked me into thinking about my feelings... I do have a quarter-baked idea for another blog post (judging by my output, it must be only one quarter-baked: if it was half-baked, I would post it).<BR/><BR/>My thought is that using the phrase "proving program properties" on an actual project is precise and defensible, but not helpful without asking "Which properties? And why?"<BR/><BR/>And using the word "correctness" is nearly useless. Note that I am talking abut the words, not the ideas.<BR/><BR/>I wonder if what really matters to me personally from verifiability is establishing <I>consistency</I>: that two or more different things in an application are <I>consistent with each other</I>.<BR/><BR/>In the case of specs and code, instead of saying "we prove the code correctly implements the spec," we say "the code and spec are consistent with each other."<BR/><BR/>And in the case of <A HREF="http://raganwald.github.com/2007/07/can-your-type-checking-system-do-this.html" REL="nofollow">strong and expressive types</A>, we say "the code is consistent with itself."<BR/><BR/>Because the inverse, showing that the code is <I>inconsistent</I>, such as sending a message to an reference that might be null at run time, is always a bad thing.<BR/><BR/>There's my quarter-baked blog post. I'm sure it's an idea that has been examined before... does anybody have an URL to share?<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195518900000#c1170527497548541502" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 7:35 PM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=1170527497548541502" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="2756908345598009167"></a> 				As to the implicit criticism of proofs:<BR/><BR/>It's easy to read this article like "proofs suck because they only work if you write a huge proof that the program satisfies some particular spec and the spec keeps changing on you". At the most generous it seems silent on the relative value of proofs vs. anything else.<BR/><BR/>The first part of that is what somebody with no experience proving things about programs might reasonably infer from the only sentence that actually had any content about your experiences with program verification: "Proving that the software meets the rigorous specification written by the customer before they had seen the software work, before they had tried it, has been of secondary importance to me in my career." Gee, that's what proving programs is like? Who in their right mind wants to do that?<BR/><BR/>Then you go on to the main point, which I think was that trying to establish the correctness of a program by any means (I'd say verification, but you seem to want that word for proofs in particular) is relatively less valuable than making prototypes and talking to customers and so on when requirements are poorly known. Contrasting this specifically with proof suggests you have reason to believe fluid requirements specifically make proofs less valuable, and the argument doesn't apply to other sorts of verifications like test suites or code audits or casting entrails.<BR/><BR/>It's like replying to an article skeptical about the value of bikes compared to walking with an article warning that if you "ride bikes too much" you can get sunburns or even skin cancer, in the context it implies this is a reason walking is better than biking (even though you might very well catch more rays on foot).<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195519980000#c2756908345598009167" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">skew</span> : 7:53 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=2756908345598009167" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="2302645064798165959"></a> 				Skew:<BR/><BR/>You are arguing with yourself, not with me.<BR/><BR/>Here's what you did: you drew your own inferences what I said, then argued with the inferences, not with what I said.<BR/><BR/>Also, I must have missed the point in my article where I suggested casting entrails at all, or equated them with talking to customers.<BR/><BR/>Would you be so kind as to forward the article you read to me for my amusement? I do not recognize it from the post I actually wrote.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195521060000#c2302645064798165959" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 8:11 PM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=2302645064798165959" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="6257203656287081756"></a> 				Oh, I don't think I'm arguing or complaining about the article at all. I didn't think the article was critical of provability, or even about proof vs testing at all. I did have a vague impression of a suggestion that proving things about software wasn't really a good idea. It took a while to even figure out where that impression was even coming from, so I thought I'd write it down, and hopefully help you figure out where people were getting that idea.<BR/><BR/>I don't think I claimed you wrote anything untrue, or even anything <I>likely</I> to be misinterpreted, just some things that might be vaguely unsettling to some pedantic souls. I guess I'm just ambiguous myself, open to even more damning interpretations when I'm just trying to offer some unemotional comments on an equanimous article :(<BR/><BR/>Casting entrails was supposed to be an example of another possible <I>verification</I> technique, which is presumably also harder to apply when requirements are not known and less valuable when you really ought to be talking to your customers anyway.<BR/><BR/>For the record, I think proving stuff about functional programs is often fun and would like to see more functional languages pick up type systems useful for the job.<BR/>Imperative languages are more trouble (aliasing), libraries and things like databases or soft real-time constraints even more so.<BR/><BR/>It would be interesting to look at program proofs and test suites in the context of changing requirements. I wonder if an internally specified program in a dependently typed language might handle changing requirements with a type-error driven refactoring like a typed language handles changing representation types. I haven't written anything like <A HREF="http://ltamer.sourceforge.net/" REL="nofollow">Lambda Tamer</A> to try it out for myself.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195533420000#c6257203656287081756" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">skew</span> : 11:37 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=6257203656287081756" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="195048127625554291"></a> 				Non6 again<BR/><BR/>"Proven correct" implies that we know a set of predicates concerning the program's behavior which, put together, define "correctness".<BR/><BR/>For mathematical programs, one can specify initial and final predicates easily.  These will typically specify the program completely.<BR/><BR/>For a more complex piece of software, for example, a content management system.  A total specification would be both over-rigid and useless.  There would be no benefit to writing a predicate for every bit of text on every page.<BR/><BR/>For larger systems, consider the benefit to specifying other behaviors:  the program closes all its sockets, the program consumes no more than 20MB of memory, the program does not write files outside of a given directory, the program does not deadlock.<BR/><BR/>The benefit to such an approach is that the project designer or architect can specify those types of properties and then derive other rules from these (foo() only occurs (dynamically) between calls to bar() and baz()).<BR/><BR/>The tools and techniques that prove correctness for mathematical software (wrt easily specified predicates) can easily apply to designer-specified properties in more real-world projects.<BR/><BR/>The benefit of this is that one architect or designer could more easily manage a piece of software (ensure it implements the design and follows the specified rules).<BR/><BR/>I don't think I follow your line of thought about consistency.  My first thought is that somebody has to encode the spec's "consistency-items" into a semantically-unambiguous form.  After you've done that, I'm not sure that we're talking about such different things.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195542360000#c195048127625554291" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Anonymous</span> : 2:06 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=195048127625554291" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="7160779001653684236"></a> 				<B>"All your process of discovery should be completed before you start development otherwise you don't understand the problem statement."</B><BR/><BR/>If this really worked they wouldn't still be inventing alternatives like Agile Methods and so on.  The problem is that 'the process of discovery' cannot, in practice, be complete before building the software.<BR/><BR/>You are right, we don't understand the problem statement.  Worse, there is no 'statement'.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/11/best-question-asked-this-week-what.html?showComment=1195553760000#c7160779001653684236" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/17440467058108985654" rel="nofollow">InternetFred</a> : 5:16 AM</div>

								<span class="item-control blog-admin pid-399548678"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=7160779001653684236" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
						
					  
					<br /> <p id="postfeeds"></p> <br />
					

					<br /> <br />
					<a href="http://raganwald.github.com/index.html">&lt;&lt; Home</a>
				</div>

			

		


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://weblog.raganwald.com/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://weblog.raganwald.com/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://weblog.raganwald.com/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://weblog.raganwald.com/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://weblog.raganwald.com/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://raganwald.github.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://raganwald.github.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://raganwald.github.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://raganwald.github.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://raganwald.github.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



		<div class="SideBarTitle">Management</div>

		<a href="http://raganwald.github.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://raganwald.github.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://raganwald.github.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://raganwald.github.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://raganwald.github.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://raganwald.github.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://raganwald.github.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://raganwald.github.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://raganwald.github.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://raganwald.github.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://raganwald.github.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://raganwald.github.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://raganwald.github.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://raganwald.github.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://raganwald.github.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://raganwald.github.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_07_01_archive.html">07/08</a> /
		
		
		<br/></p>
		<br/>

		

	</div>





	<div style="visibility: hidden">
		
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>
<html> 
<head>
        
        <title>Thus Spake Joel</title>

	<link rel="stylesheet" type="text/css" href="/blog.css" />
	<link rel="stylesheet" type="text/css" href="/sunburst.css" />



	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>

<body>

	<div id="leftcontent">
			<a href="http://raganwald.github.com/"><img src="http://raganwald.github.com/assets/raganwald_2008_350_150" 
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/></a><br/>
			
				<div class="DateHeader">Monday, December 03, 2007</div>
			

			<div class="Post"><a name="3313690900406847019">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/thus-spake-joel.html" title="permanent link">Thus Spake Joel</a></span>
					<div style="clear:both;"></div><blockquote>What you&rsquo;ll see is that the hard-core geeks tend to give up on all kinds of useful measures of quality, and basically they get left with the only one they can prove mechanically, which is, <strong>does the program behave according to specification</strong>. And so we get a very narrow, geeky definition of quality: how closely does the program correspond to the spec. Does it produce the defined outputs given the defined inputs.<br />  <br />  The problem, here, is very fundamental. In order to mechanically prove that a program corresponds to some spec, the spec itself needs to be extremely detailed. In fact the spec has to define everything about the program, otherwise, nothing can be proven automatically and mechanically. Now, if the spec does define everything about how the program is going to behave, then, lo and behold, it contains all the information necessary to generate the program! And now certain geeks go off to a very dark place where they start thinking about automatically compiling specs into programs, and they start to think that they&rsquo;ve just invented a way to program computers without programming.<br />  <br />  Now, this is the software engineering equivalent of a perpetual motion machine. It&rsquo;s one of those things that crackpots keep trying to do, no matter how much you tell them it could never work. If the spec defines precisely what a program will do, with enough detail that it can be used to generate the program itself, this just begs the question: how do you write the spec? Such a complete spec is just as hard to write as the underlying computer program, because just as many details have to be answered by spec writer as the programmer. To use terminology from information theory: the spec needs just as many bits of <a href="http://en.wikipedia.org/wiki/Information_entropy" title="Information entropy - Wikipedia, the free encyclopedia">Shannon entropy</a> as the computer program itself would have. Each bit of entropy is a decision taken by the spec-writer or the programmer.<br />  <br />  So, the bottom line is that if there really were a mechanical way to prove things about the correctness of a program, all you&rsquo;d be able to prove is whether that program is identical to some other program that must contain the same amount of entropy as the first program, otherwise some of the behaviors are going to be undefined, and thus unproven. So now the spec writing is just as hard as writing a program, and all you&rsquo;ve done is moved one problem from over here to over there, and accomplished nothing whatsoever.</blockquote><div>&mdash;Joel Spolsky, <a href="http://www.joelonsoftware.com/items/2007/12/03.html" title="Talk at Yale: Part 1 of 3">Talk at Yale: Part 1</a></div><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/thus-spake-joel.html" title="permanent link">3:25 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			
			    <div class="blogComments">
                                
                                <a name="comments"></a><strong>Comments on &ldquo;<em>Thus Spake Joel</em>&rdquo;</strong>:<br/>
						
							<div class="blogComment">
								<a name="6002302241981409515"></a> 				And yet most development requires a fairly detailed documentation.  Specifically upping the detail of the spec documentation for the sake of generating the program is most likely a productivity black hole, but using the spec you must create anyway to generate a basic framework is most definitely not.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1196735520000#c6002302241981409515" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">huh?</span> : 9:32 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=6002302241981409515" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="3192269752862964275"></a> 				Yes, huh?, it&rsquo;s important to keep things in perspective. Proving a program satisfies an incredibly rigorous specification doesn&rsquo;t mean you&rsquo;ve done less work (you may have doen twice as much work as just writing a program).<BR/><BR/>But less detailed specs still provide value. As do automated tests. As does static typing.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1196746620000#c3192269752862964275" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 12:37 AM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=3192269752862964275" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="8922473913564120074"></a> 				Definitely in agreement there.  Especially when many (especially government customers) want that incredibly detailed spec upfront, and it all changes into some unrecognizable form during the course of development as most projects are wont to do.<BR/><BR/>Why no! I'm not frustrated at all... why do you ask? ;)<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1196758980000#c8922473913564120074" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">huh?</span> : 4:03 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=8922473913564120074" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="1715907688312588974"></a> 				I agree with the general point, but he goes too far - it's easier to rigorously specify a fast 3-SAT solver than to implement one, and you can't automatically derive one from the other (in either direction, cf halting problem).<BR/><BR/>Of course in usual business practice the algorithms are simple compared to the behaviour. The 'hard-core geeks' aren't always most interested in the usual business practice!<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1196761080000#c1715907688312588974" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/08193244312398482089" rel="nofollow">Sam McCall</a> : 4:38 AM</div>

								<span class="item-control blog-admin pid-259137300"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=1715907688312588974" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="3598458394681525967"></a> 				Two points: one, Joel is describing <A HREF="http://en.wikipedia.org/wiki/Formal_methods" REL="nofollow">formal methods</A> and one of their main accepted criticisms, i.e. that the formal specification starts to resemble programming and all you've achieved is moving the problem from the domain of a programming language to the domain of the specification language. <BR/><BR/>Two, in many cases the specification language can be tailored for the problem domain and this is exactly what DSLs do. So by moving the problem from the domain of the general purpose programming language to the domain of a problem-specific DSL it is easier to write the code. Using a DSL will not magically avoid all bugs, but it will make you more productive and it will hopefully prevent you hanging yourself on all the rope that a general purpose programming language would give you.<BR/><BR/>-- Liwp<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1196774040000#c3598458394681525967" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Liwp</span> : 8:14 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=3598458394681525967" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="5949299651984870806"></a> 				Joel is completely wrong.  His fundamental error is in his "fundamental problem": he says that the spec needs to be extremely detailed and "define everything about the program".  He has the wrong idea of what specification means.  It is in fact perfectly possible to prove useful and interesting things about concrete implementations on the basis of abstract specifications.<BR/><BR/>I think the main notion he's missing is that of refinement: a spec P refines another spec Q if everything true of Q is true of P.  Then Q is your abstract spec, and P is a "more concrete" spec.  If you've proven that Q is, say, deadlock free, and you've proven that P is a refinement of Q, then you know that P is deadlock free also.<BR/><BR/>The idea is to produce a chain of specs, starting with a very loose and abstract (explicitly _not_ detailed) specification of what is required, which is then refined in stages until eventually you have an implementation.  At some time you move from the domain of things you can't implement (eg a spec involving "the real numbers") to the domain of things you _can_ implement (eg a spec involving some computable approximation of the real numbers).<BR/><BR/>This is, admittedly, still work in progress - our ability to produce and work with formal specifications is underdeveloped compared to our ability to produce and work with executable programs (and we all know how hard this is!), but it's coming along.<BR/><BR/>If you want real world examples of specification languages which include these notions of refinement and are used in industrial context, look no further than the process algebra CSP, and the algebraic specification language CASL.  CSP has a long and well documented history of use in industry (at least those corners that care enough, and can pay enough, to do this).  CASL is less widely used than CSP (and much younger), but is more completely formally specified, and is pushing the boundaries of tool support for formal specification languages via its toolset Hets, which allows specification at various levels of abstraction, using heterogeneous combinations of specification languages (ie mix and match), with solid integration with automatic and assisted theorem provers.<BR/><BR/>Disclaimer: I'm the maintainer of part of hets - the CSP (or more properly, CSP-CASL) part.  :-)<BR/><BR/>I suspect that Joe misses all this because he's a pragmatic guy so he doesn't care what we academics are up to and so (like most of the software world) his idea of specification is UML and natural language.  There's more to specification than that, however - the trick is to formalise your specification tool, ie to use a formal specification language.  Then interesting things become possible.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1196775120000#c5949299651984870806" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">gimbo</span> : 8:32 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=5949299651984870806" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="4858378993087372429"></a> 				Having been interested in formal methods for a long time, and being a developer of commercial software, I'd like to address the fans of formal methods who take exception to Joel's point.<BR/><BR/>I would suggest you have to understand it in the context of his business: commercial software development for business customers.  In this environment, the focus is on solving customers' problems as quickly and cheaply as possible, and "correctness" is a subjective, not an objective standard.<BR/><BR/>If he were a contractor for, say,  government or large institutions, where accountability and process are valued more highly than turnaround or "warm fuzzies", formal specifications with refinement might be more appealing.<BR/><BR/>I hope that research continues into formal methods, but I think it would be a mistake to assume that this approach will ever appeal to commercial developers in a business marketplace.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1196776980000#c4858378993087372429" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Marc Hamann</span> : 9:03 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=4858378993087372429" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="7218427326878323542"></a> 				this solution tends to infinity, if the spec has to be very detailed as the program, so where is the spec to prove that you spec does what is suppose to do, and this will go, and go, and go on....<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1196797680000#c7218427326878323542" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/10122588151735674998" rel="nofollow">mikerod</a> : 2:48 PM</div>

								<span class="item-control blog-admin pid-453467376"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=7218427326878323542" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="4199172063922536890"></a> 				The problem here is one of a mathematician talking about business.<BR/><BR/>A business spec is simple: "Do what the business wants you to do."  That specification has nothing to do with algorithms or code, and only even meets business processes in that dark world of "business requirements documents" and other unsavory monographs.<BR/><BR/>For every application I've ever worked on, things have fallen into two camps: either 1) no formal specification actually existed, or 2) the formal specification that existed was actually <I>less</I> useful as it became more specific.<BR/><BR/>#1 is the tact taken by Agile development, who defines their specifications in terms of "customer sign-off": "Does it meet spec?" becomes "Does the customer say it's done?"<BR/><BR/>The #2 case occurs when business people try to code in English, usually because they've been verbally abused by developers for not giving them clear enough specifications.  Unfortunately, English is a horrible programming language, and the pidgin, bullet-point-ridden dialect of English that makes it into those requirement documents is even worse.<BR/><BR/>Ultimately, the real requirements for a program look nothing like formal specs for the code.  The requirements have to do with budget, with enabling the business to do more work for less money, and with company politics.  Algorithms are at least two or three steps removed from any kind of real program requirement: the important part is delivering a solution, not the code.<BR/><BR/>For more on this, also see <A HREF="http://enfranchisedmind.com/blog/2007/09/11/development-acceleration-the-second-derivative-of-functionality/" REL="nofollow">my blog post on the second derivative of functionality</A> and the passing discussion of functionality entropy that I have in there.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1196832720000#c4199172063922536890" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/15576124960718643532" rel="nofollow">Robert Fischer</a> : 12:32 AM</div>

								<span class="item-control blog-admin pid-1999105704"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=4199172063922536890" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="2987521230311427914"></a> 				I do not agree that detailed specs are a part of a "perpetual motion machine" (Joel), nor part of a "solution tend[ing] to infinity" (mikerod).    Detailed specs, whether on paper, as test suite, or as an independent program, are a necessary dual of the main program to verify correctness.    This double-development mimics (or is a result of) pair programming found in XP.    There is the added work to compare the program to the spec for sure.  The total cost is certainly over double that of simple development, but that is well short of infinity.<BR/><BR/>Of course, acquiring the proper spec is another matter entirely.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1196878020000#c2987521230311427914" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Kyle Lahnakoski</span> : 1:07 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=2987521230311427914" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="1959404663311404714"></a> 				Joel has a point but goes much too far.  <BR/><BR/>Quick example: It is easier to specify that a list in sequence alphabetically than to write a good sorting program.<BR/><BR/>Another quickie: How do you have somebody come in and work on testing if there is no spec?  They can verify it doesn't crash.  But anything more is just guesswork.  You can ask them to look at the code and see if the program does what it is coded to do, but that's just testing the compiler.<BR/><BR/>You don't always need to write a big detailed document to write an app, but when the team gets large and the system itself is complex, you need written specs.<BR/><BR/>When everybody on the team was involved in the conception of the product, they're more likely to know what to do.  <BR/><BR/>When you hire an outside team to write software, how do you tell them what to do?  Is it all verbal?<BR/><BR/>Yes, it's hard to write a spec, that's why in-house software teams exist.  They eventually get to understand implicitly what is needed.  Coordination and communications is easier.<BR/><BR/>The agility folks argue for working with the customers during design.  The customers are often too busy to spend time reviewing half-built software.<BR/><BR/>Writing documents can be a black hole for productivity.  It can become an obsession with "Software Process". We all notice that the CMM from SEI has not caught on like wildfire.  But Joel goes too far.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1196982000000#c1959404663311404714" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/17440467058108985654" rel="nofollow">InternetFred</a> : 6:00 PM</div>

								<span class="item-control blog-admin pid-399548678"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=1959404663311404714" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="3301705019845050450"></a> 				> Another quickie: How do you have <BR/>> somebody come in and work on<BR/>> testing if there is no spec?<BR/>><BR/>Give them exemplars of the work to do which exercises the features that was just built.  We call these "stories".<BR/><BR/>> You don't always need to write a<BR/>> big detailed document to write an <BR/>> app, but when the team gets large <BR/>> and the system itself is complex, <BR/>> you need written specs.<BR/>><BR/>If your spec is too big to fit on a note card, it's too big.<BR/><BR/>I think there's a difference here between "specs" (which are functionality-based) and "tests" (which are code-based).  A test verifies that a piece of code works as expected.  The "specs" that I'm talking about define the work that the application is supposed to do -- the problem that it is supposed to be solving.  If the developers aren't working to solve a problem -- if they're working just to satisfy a set of check-box requirements -- then you're heading into trouble in a hurry.<BR/><BR/>> When everybody on the team was<BR/>> involved in the conception of<BR/>> the product, they're more likely<BR/>> to know what to do.<BR/>><BR/>> When you hire an outside team<BR/>> to write software, how do you<BR/>> tell them what to do? Is it<BR/>> all verbal?<BR/>><BR/>Mostly -- it's also learning-through-example.  First, pair them up with someone who groks the project until they get a strong handle.  When they move out on their own, if they don't understand why some current piece of software works the way it does, or if they aren't sure how to do a piece of software, then.  And if they code it wrong one time, then the customer will catch it, the team will fix it, and they'll know not to do it again.<BR/><BR/>> Yes, it's hard to write a spec,<BR/>> that's why in-house software<BR/>> teams exist. They eventually<BR/>> get to understand implicitly<BR/>> what is needed. Coordination<BR/>> and communications is easier.<BR/>><BR/>And I'll take co-ordination and communication over specs any day.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1197035280000#c3301705019845050450" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Robert Fischer</span> : 8:48 AM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=3301705019845050450" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="3464377483750927070"></a> 				Let's rewrite this...<BR/><BR/>"So now the spec writing is just as hard as writing a program, and all youâ€™ve done is moved one problem from over here to over there, and accomplished nothing whatsoever."<BR/><BR/>...as this, and pretend it were written a few decades ago:<BR/><BR/>"So now writing Fortran code is just as hard as writing assembly code, and all you've done is moved one problem from over here to over there, and accomplished nothing whatsoever."<BR/><BR/>...or take Python vs. C as your examples.<BR/><BR/>Yes, some formal methods are pie in the sky, and you'll never have a "one size fits all" specification language that eliminates programming.  But you can invent new abstractions to be used as more compact forms of source code that are more closely related to the real-world problem at hand.<BR/><BR/>The key thing is to consider more and more "development artifacts" as source code.  That is, instead of using a white board and then throwing away your drawings, or having an e-mail exchange and then forgetting your conclusions, you associate real pieces of "source code" with each of those.  You bridge the gap between code and ideas.<BR/><BR/>At the end of the day, you're still only attacking the "accidental" problem of programming; as Brooks famously pointed out years ago the "essential" problem remains.<BR/><BR/>For some practical ideas in this space, see:<BR/><BR/>1. EMF for a practical model-driven development technology, specifically for data modeling;<BR/><BR/>2. Macro programming in Lisp, embedded DSLs with Ruby, and even "Language-oriented programming" (each about raising abstraction levels in source code);<BR/><BR/>3. Test-driven development using xUnit or TestNG, automated acceptance testing with FitNesse, etc.  Test cases often serve as very compact representations of a requirement, and have the great side-benefit that they can run each time your code builds to make sure you're not off track.<BR/><BR/>There are others...<BR/><BR/>It's getting better every day.  Developers are incorporating more and more things as "source code", and the cumulative effect is higher-quality software.  But there is no magic bullet!<BR/><BR/>Sometimes, it pays not just to start hacking away and building up a piece of software in the language of your day.  It may pay, in many situations, to start by building the tools you need to build your software effectively.  This might be a DSL, a rigorous way of collecting test cases, etc.  With that little up-front investment, you can end up with a vastly better (and more maintainable) product later on.  See e.g. Paul Graham's comments about his use of Lisp Macros in Viaweb in "Beating the Averages", or his book "On Lisp."  In the latter, he suggests that Lisp programmers don't build their programs "in Lisp", but they build them "On Lisp", in other words, they create a DSL for the problem they are solving using Lisp.  Ideas like this are not limited to esoteric languages, and personally I wish I saw more "mainstream" developers taking them seriously.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1197060540000#c3464377483750927070" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Andrew Montalenti</span> : 3:49 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=3464377483750927070" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="1574957178609910756"></a> 				Andrew:<BR/><BR/>I like your argument about abstractions. You are preaching to the Choirmaster.<BR/><BR/>However, I am scratching my head about something. I understand Joel to be talking about a "specification" as something that unambiguously defines the behaviour of the program <I>but is not the program</I>.<BR/><BR/>Therefore, in his world, you write a specification and you also write a program, and you use some means of verifying that the program and specification match.<BR/><BR/>With what you are describing&mdash;DSLs, abstractions, FORTRAN&mdash;it sounds like you write the specification and stop right there. You don&rsquo;t also write a program.<BR/><BR/>In which case, you do not do twice as much work, agreed.<BR/><BR/>But if I understand you correctly, you also do not end up with a program that meet some specification, you end up with a program that in some way is also a specification.<BR/><BR/>Is that what you are saying? If so, I am in your corner, however it does not really invalidate Joel&rsquo;s point, rather it is a different strategy for producing software.<BR/><BR/>Remember, the comparison to FORTRAN vs. Assembler ought to be "If FORTRAN is powerful enough to unambiguously specify the behaviour of an Assembler program, then we ought to throw the Assembler away and just write FORTRAN, not try to write both side by side."<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1197061140000#c1574957178609910756" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 3:59 PM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=1574957178609910756" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="6893554377568128231"></a> 				To validate the design you needn't go to the same depth of detail. Before they spend time building a house, architects usually draw up 'blueprints' that a) take way less time and b) reduce the complexity (from 3D to 2D), but still provide enough information to validate it.<BR/><BR/>We generally express the solution at <A HREF="http://theprogrammersparadox.blogspot.com/2007/10/repeated-expressions.html" REL="nofollow">least three times</A>.<BR/><BR/>Paul.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1197065220000#c6893554377568128231" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/02349253120538728302" rel="nofollow">Paul W. Homer</a> : 5:07 PM</div>

								<span class="item-control blog-admin pid-1233049894"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=6893554377568128231" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="184110076014704274"></a> 				Spolsky wrote, "Now, if the spec does define everything about how the program is going to behave, then, lo and behold, it contains all the information necessary to generate the program!"<BR/><BR/>Other pointy-headed people here have commented but, frankly, I do not think it has been stated clearly enough: formal specifications are not executable in general. Example: Halting Problem. The point of refinement vis-a-vis software development is to get from an arbitrary specification to an executable specification, a.k.a. an algorithm.<BR/><BR/>Some specifications don't define algorithms; some do. Some specifications define a collection of algorithms and need to be refined to get down to a single algorithm which can be extracted from the description. (A program is not a collection of algorithms; it is a single algorithm.)<BR/><BR/>Any programmer who doesn't understand all this needs to go back to college, or at least crack open a textbook or two again to take a refresher in basic computer science... and that goes twice for programming pundits who carry so much weight with the community.<BR/><BR/>I feel this sort of glibness is really, REALLY inexcusable. Sometimes when I read programming blogs I feel like I'm watching Hardcopy or Geraldo Rivera. It's that bad.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1197160320000#c184110076014704274" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Frank Atanassow</span> : 7:32 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=184110076014704274" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="8477000129050576178"></a> 				Maybe this presentation (http://www.cs.swan.ac.uk/~csteme/SEFM-Presentation.pdf) can clarify why is important to study  refinement in Process Algebra (CSP) and algebraic specification (CASL) and relate them to the notion of Specification based Testing.<BR/>If someone is interested in the paper , google "Specification based testing for refinement"<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/12/thus-spake-joel.html?showComment=1198875180000#c8477000129050576178" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<span class="anon-comment-author">Teme</span> : 3:53 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=8477000129050576178" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
						
					  
					<br /> <p id="postfeeds"></p> <br />
					

					<br /> <br />
					<a href="http://raganwald.github.com/index.html">&lt;&lt; Home</a>
				</div>

			

		


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://reginald.braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://raganwald.com/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://raganwald.com/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://raganwald.com/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://raganwald.com/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://raganwald.com/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://raganwald.github.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://raganwald.github.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://raganwald.github.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://raganwald.github.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://raganwald.github.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



		<div class="SideBarTitle">Management</div>

		<a href="http://raganwald.github.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://raganwald.github.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://raganwald.github.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://raganwald.github.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://raganwald.github.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://raganwald.github.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://raganwald.github.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://raganwald.github.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://raganwald.github.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://raganwald.github.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://raganwald.github.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://raganwald.github.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://raganwald.github.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://raganwald.github.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://raganwald.github.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://raganwald.github.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_07_01_archive.html">07/08</a> /
		
		
		<br/></p>
		<br/>

		

	</div>





	<div style="visibility: hidden">
		
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>
<html> 
<head>
        
        <title>IS-STRICTLY-EQUIVALENT-TO-A</title>

	<link rel="stylesheet" type="text/css" href="/blog.css" />
	<link rel="stylesheet" type="text/css" href="/sunburst.css" />



	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>

<body>

	<div id="leftcontent">
			<a href="http://raganwald.github.com/"><img src="http://raganwald.github.com/assets/raganwald_2008_350_150" 
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/></a><br/>
			
				<div class="DateHeader">Monday, April 07, 2008</div>
			

			<div class="Post"><a name="5225863504730281301">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html" title="permanent link">IS-STRICTLY-EQUIVALENT-TO-A</a></span>
					<div style="clear:both;"></div><blockquote>Favor object composition over class inheritance.</blockquote><div>&#8212;Chapter one of <a href="http://www.amazon.com/gp/product/0201633612?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201633612">Design Patterns: Elements of Reusable Object-Oriented Software</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201633612" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></div><br />Maxims like this drive me crazy. On the one hand, there in one sentence is some of the best advice I can imagine for designing Object-Oriented software. On the other hand, following this advice without any idea why one favors one over the other, without any idea when class inheritance is the right thing to do&#8230;<br /><br />As <a href="http://www.amazon.com/gp/product/1570627169?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1570627169" title="Narrow Road to the Interior: And Other Writings (Shambhala Classics)">Basho</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=1570627169" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> said, &#8220;Do not seek to follow in the footsteps of the men of old; seek what they sought.&#8221;<br /><br />Perhaps of the maxim &#8220;Favor object composition over class inheritance&#8221; is what happens when we seek what they sought, when we question the fundamentals, when we ask ourselves, &#8220;<span style="font-style:italic;">What does inheritance really mean?</span><br /><br />So: What does it mean when we go to the design white board (or pick up a 3x5 card in a design session) and boldly write:<br /><pre><code><br />Manager IS-AN Employee</code></pre><br />???<br /><br />Commenting on <a href="http://raganwald.github.com/2008/03/is-is-has.html">IS-A IS-A HAS-A</a>, Robert Fisher pointed out that there is no definitive meaning to inheritance in programming languages. Another reader reminded him that Bertrand Meyer&#8217;s <a href="http://www.amazon.com/gp/product/0136291554?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0136291554">Object-Oriented Software Construction</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0136291554" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> identifies no fewer than twelve(!) kinds of inheritance. I took that to support Robert&#8217;s point: if there really are twelve different kinds of inheritance, it is easy to see how two reasonable, intelligent people could each write &#8220;A IS-A B&#8221; and mean two completely different things.<br /><br /><strong>Should the compiler always win?</strong><br /><br />There is one argument&mdash;the compiler always wins&mdash;where the only thing that matters is what a program <em>does</em>. A program&#8217;s code means whatever effect the program has when it runs. So when you organize your code around a result like the fastest possible performance, or the smallest possible program, and in doing so you use features like inheritance strictly because they help your technical objective and not because you think they carry any meaning.<br /><br /><div class="book"><hr><em><a id="lnx0" name="evtst|a|0262561158" href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262561158"><img src="http://raganwald.github.com/uploaded_images/a_little_java-777624.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262561158" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br /><br /><a name="evtst|a|0262561158" href="http://www.amazon.com/gp/product/0262561158?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262561158">A Little Java, a Few Patterns</a>: The authors of <a name="evtst|a|0262560992" href="http://www.amazon.com/gp/product/0262560992?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262560992">The Little Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262560992" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> and <a name="evtst|a|026256114X" href="http://www.amazon.com/gp/product/026256114X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256114X">The Little MLer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256114X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> bring their deep and important insights about programming to the Java language. This post will help explain why I never say never use inheritance.</em><hr></div>This practice is programming for the compiler. Smeone who is programming for the compiler doesn&rsquo;t even think in terms of &ldquo;IS-A,&rdquo;, they think directly in their language&rsquo;s features&mdash;like interfaces, abstract classes, or modules.<br /><br />I appreciate that point of view, but I believe that we can produce <em>even better</em> software if we decide that language features like inheritance have a semantic meaning above and beyond what the compiler does with them. Especially when we are considering projects that have multiple programmers working on them over a substantial period of time. Such projects must produce <em>sustainable</em> code, not just code that works today.<br /><br />When we have a shared understanding of inheritance&rsquo;s semantic meaning, our code more closely resembles the problem it solves. If it is just an engineering tool, a statement like Manager IS-AN Employee may have no parallel in the real world. Are managers really employees? When we declare other relationships such as HAS-MANY, we work very hard to make our code model the real world. Why would IS-AN be any different?<br /><br />That being said, there seem to be as many opinions of what class inheritance means as there are programmers. Do any two programmers&mdash;much less a full team&mdash; agree on exactly what &ldquo;Manager IS-AN Employee&rdquo; means if Employee and Manager are both classes?<br /><br />All I can do is share is a meaning that has worked well for me: Strict Equivalence. I&#8217;m going to describe what I mean and illustrate some of the consequences of adopting this as the standard meaning of &#8220;IS-A&#8221; on your project.<br /><br />(I am not trying to say that Strict Equivalence is the only or even best way to build OO systems: I have worked on many projects with a different understanding, and they worked out just fine.)<br /><br /><strong>Strict Equivalence</strong><br /><br />You know the <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle</a>, of course. In short, if X IS-A Y, then anywhere you could use a Y, you can substitute an X and things should Just Work. So if every Manager IS-AN Employee, every piece of code that operates on Employees can operate on Managers and Just Work.<br /><br />What I just said is the Liskov Substitution Principle, but there is a lot of room for discussion over what &#8216;just works&#8217; means. So here is something much more specific, Strict Equivalence.<br /><br />A <em>client</em> is a piece of code that <em>uses</em> an entity. Strict Equivalence is the following property: X IS-A Y if and only if it is the case that for every client that uses an object of class Y, you can substitute an object of class X and the results from the perspective of the client are <em>indistinguishable</em>.<br /><br />Note that clients expecting an <em>X</em> can presumably distinguish an X from a Y, but that&rsquo;s because they know about the differences between X and Y. Note also, and with emphasis, that we are talking about <em>classes</em>. Specifically, concrete classes. If X and Y are Java interfaces or C++ abstract base classes, there is no difference between Strict Equivalence and Liskov Substitutability, which leads to a completely different maxim, &ldquo;program to interfaces and not implementations,&rdquo; or my preferred interpretation&mdash;&ldquo;Favour exposing interfaces over exposing implementations.&rdquo;<br /><br />This is not the same as Liskov Substitutability. With Liskov Substitutability, X IS-A Y if and only if it is the case that for every client that uses an object of class Y, you can substitute an object of class X and the results will be <em>semantically valid</em> although they may differ from the perspective of the client. Again, we are talking about a case where the client is using a Y, not using an interface. For example:<br /><pre><code><br />public class OurClient {<br />  public void consumeY(final Y someY) {<br />    ...<br />  }<br />}</code></pre><br />This code is a client that uses and depends on objects of class Y, not an interface that Y implements.<br /><br /><blockquote>Strict Equivalence is a specialization of Liskov Substitutability</blockquote><br /><br />One of the nice properties of Strict Equivalence is that it also guarantees semantic validity: It guarantees that you can substitute an X for a Y and since the results are indistinguishable to a client expecting a Y, the results will be semantically valid as well. Therefore, Strict Equivalence is a specialization of Liskov Substitutability.<br /><br />So if you like Liskov Substitutability, you ought to also like Strict Equivalence. But it is still a specialization, and a very restricted specialization at that. Let&#8217;s see how.<br /><br />Consider something very basic. Overriding a method. Isn&#8217;t that what you&#8217;re supposed to do? You have a method in a superclass, but you need a different, more specialized behaviour in the subclass. This is OOP 101. And it&#8217;s usually wrong. Okay, wrong is a strong word. It&#8217;s usually a violation of Strict Equivalence. Let&rsquo;s have a look at why.<br /><br />Take our Employees and Managers, where every Manager IS-AN Employee. We want to have a calculate_annual_bonus method for employees. You can imagine writing it, blah-blah personal goals set in performance review, blah-blah overall division profit.<br /><br />Now what happens with managers? Perhaps the business rule is that managers get 10% of the bonus of each of their reports, like an <abbr title="Multi-Level Marketing, a/k/a/ Pyramid Fraud">MLM</abbr> plan. So you write something like:<br /><pre><code><br />class Employee<br />  def calculate_annual_bonus<br />    personal_goals.select(&amp;:achieved).map(&amp;:incentive).inject(&amp;:+) +<br />      self.division.declared_profit_share_amount<br />  end<br />end<br /><br />class Manager &lt; Employee<br />  def calculate_annual_bonus<br />    reports.map(&amp;:calculate_annual_bonus).inject(&amp;:+) * 0.1<br />  end<br />end</code></pre><br />(You can easily imagine the Java equivalent, starting with public class Manager extends Employee&#8230;)<br /><br />With Liskov Substitutability, everything is fine: you have some code that transfers a bonus to an employee&#8217;s bank account. It asks the employee object to calculate the annual bonus, and it transfers that amount. Nice. But Strict Equivalence prohibits this simple and common construction.<br /><br />The reason this is prohibited is that if we allow a subclass to override the bonus calculation, we have effectively declared that the amount of annual bonus is arbitrary for employees. Our code <em>says</em> that the correct calculation is <code>personal_goals.select(&amp;:achieved).map(&amp;:incentive).inject(&amp;:+)</code> <code>+</code> <code>self.division.declared_profit_share_amount</code>, but in reality when we have an employee object, that may not be true.<br /><br />Overriding the annual bonus calculation breaks the declared behaviour of the Employee class. It is no different than if some code in your Manager class reached out like a <a href="http://avdi.org/devblog/2008/04/01/announcing-ninja-patching/" title="Announcing Ninja-Patching!">ninja</a> and redefined the calculate_annual_bonus method in the employee class. From the perspective of a client using an employee object, how is that different?<br /><br />With Strict Equivalence, you may only override the annual bonus calculation if client code like pay_annual_bonuses cannot tell the difference. So when I am looking at the Employee class, I can&#8217;t tell whether someone has written a Manager class. But I do have confidence that if they do write a Manager class, they are not to override the calculate_annual_bonus calculation in a way that breaks my code: whatever they do, it must be indistinguishable to me.<br /><br /><strong>But&hellip; but&hellip; but&hellip;</strong><br /><br />Strict Equivalence seems at first to violate the whole point of polymorphism. Why should a client know or care what a method does? Why should it rely on a what an Employee defines as the correct calculation for an annual bonus?<br /><br />One argument in favour of overriding is to talk about the separation of interface and implementation. Orthodox OO teaches that a class&rsquo;s <em>interface</em> is its collection of method signatures, and its <em>implementation</em> is what those methods happen to do. The notion is that clients should program to the interface only: the implementation is the class&rsquo;s private business.<br /><br />This practice is reified in C++, where the public interface of a class is found in a separate header file from the implementation. Sounds good. Now what happens with Java? In Java, a class&rsquo;s interface and its implementation are in the same file. But if you want to give someone just the collection of method signatures, Java provides interfaces. So if you as the author wish to have clients program strictly to method signatures, you can give them an interface.<br /><br />The point here is that Strict Equivalence is <em>not</em> in conflict with orthodox interface-oriented design: they can live happily side-by-side if you simply use interfaces when you mean interfaces, abstract methods when you mean abstract methods, and if you think twice before providing a concrete method in a class your provide to clients.<br /><br />The difference comes up when you ask a client  to use a class and provide an actual working method. In our example, we deliberately put behaviour in the Employee class, even though we have alternatives. In Ruby, we could borrow an idiom from Smalltalk and write:<br /><pre><code><br />def calculate_annual_bonus<br />  raise 'implemented by subclass'<br />end</code></pre><br />In Java, we could declare it to be an abstract method:<br /><pre><code><br />abstract class Employee {<br />  abstract public Money calculateAnnualBonus();<br />  protected final Money baseAnnualBonus() {<br />    // helper calculation<br />  }<br />}<br /><br />public class Contributor extends Employee<br />  public Money calculateAnnualBonus() {<br />    return baseAnnualBonus();<br />  }<br />}<br /><br />public class Manager extends Employee<br />  public Money calculateAnnualBonus() {<br />    return ...<br />  }<br />}</code></pre><br />Is that so hard? This conforms perfectly to Strict Equivalence. The Employee class guarantees that there is a calculateAnnualBonus method, but it doesn&#8217;t guarantee what it will be. There is a protected helper method so that each subclass doesn&#8217;t have to repeat the calculation. And you can see that both the Contributor and Manager classes guarantee the exact calculation.<br /><br />We <em>chose</em> to provide clients with an Employee class that defined the exact calculation for the annual bonus. Given that we could have written our code another way, why shouldn&rsquo;t a client assume that we deliberately wanted them to depend on the calculation? Why shouldn&rsquo;t a client infer that the annual bonus calculation is part of the definition of what it means to be an employee?<br /><br /><strong>Theories X, Y, and Law Enforcement</strong><br /><br />In Management Science, a <a href="http://en.wikipedia.org/wiki/Theory_X_and_theory_Y#Theory_X">Theory X </a> manager believes &#8220;workers need to be closely supervised and comprehensive systems of controls developed.&#8221; A <a href="http://en.wikipedia.org/wiki/Theory_X_and_theory_Y#Theory_Y">Theory Y</a> manager &#8220;will try to remove the barriers that prevent workers from fully actualizing themselves.&#8221;<br /><br />Some languages provide tools for enforcing some of the semantics of Liskov Equivalence. I personally have mixed feelings about this. I actually like this idea of the compiler noticing that I am trying to call the non-existent annual_bonus method of an Employee object. And enforcing Strict Equivalence would be terrific.<br /><br />But what I don&#8217;t like is actually not the language&#8217;s fault. I don&#8217;t like it when I have to deal with a code base where people assume that as long as they are following the language&#8217;s rules, the result must be well-designed OO software. So net-net, I like languages providing mechanisms for enforcing obvious things about inheritance. But philosophically, I want to <em>seek what the language designers sought</em> and design to the principle of the law, not the letter of the law.<br /><br />Let&#8217;s talk about Java first. Java provides two tools&#8212;the abstract and final keywords&#8212;for partially enforcing Strict Equivalence. As shown above, an abstract method lets us declare that all Employees have a calculate_annual_bonus method without making any guarantee as to what it will return. A final method lets us declare that its calculation is invariant. If we write:<br /><pre><code><br />class Employee {<br />  final public Money calculateAnnualBonus() {<br />    // calculation...<br />  }<br />}</code></pre><br />Then we know that all Employees have the same calculation. It is illegal to implement a different calculation for the Manager subclass. And by extension, if we fail to mark a method final, we know that its implementation is <em>not</em> guaranteed. A non-final method in a non-final Java class is unreliable, it&#8217;s just like functionality without a test in a test-infected program. It is <strong>not</strong> part of a class&#8217; contract with its clients.<br /><br />I conjecture that this is the basis of the suggestion that <a href="http://cafe.elharo.com/blogroll/final-good/" title="Final == Good">methods should be final by default</a>. If a class is not final and it has a non-final method, you can override it and break Strict Equivalence. So with Java, if you want a method&#8217;s behaviour to be part of a class&#8217; contract with its clients, you have to make it final.<br /><br />There is a shortcoming to this system. It <em>is</em> possible to override a method without breaking Strict Equivalence. <br /><br />The limitation of using the final keyword (or whatever tool your compiler gives you to prevent overriding) is that it prohibits a very large class of specializations that are useful and do not violate Strict Equivalence. It is as if the Police Chief decided to fight crime by imposing a curfew on the entire town.<br /><br />It is not that <em>all</em> ways of overriding a method break Strict Equivalence. Let&#8217;s go back to our employees for a moment:<br /><pre><code><br />class Employee<br />  attr_accessor :manager<br /><br />  def something_serious<br />    # ... just do it<br />  end<br />end<br /><br />class ProbationaryEmployee &lt; Employee<br />  def something_serious<br />    returning(super) do<br />        self.manager.notify(self, 'did something serious')<br />    end<br />  end<br />end</code></pre><br />This is a little contrived, but the point here is that although a ProbationaryEmployee overrides the something_serious method, it does so in a way that is presumably indistinguishable from the perspective of client code. It does something serious and returns the same result, but there is an extra side-effect that matters to probationary employees and their managers.<br /><br />This conforms to Strict Equivalence because to a client method, the results are identical. A ProbationaryEmployee will pass the same tests and you can insert assertions as you see fit.<br /><br />The only problem is, how do we know that ProbationaryEmployee adheres to Strict Equivalence and Manager does not? How can programmers write code like something_serious? Just writing any old method, calling super, and hoping that you haven&#8217;t broken the Employee class is rather like tossing salt over your shoulder to ward off evil spirits. And never overriding Employee methods is rather drastic. What to do?<br /><br /><strong>When the going gets tough, the tough redecorate</strong><br /><br />Solving problems like this is a lot of the motivation behind Aspect-Oriented Programming systems like Lisp&#8217;s <a href="http://www.dreamsongs.com/NewFiles/ECOOP.pdf" title="The Common Lisp Object System: An Overview (PDF)">Flavors &amp; CLOS</a>, the <a href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator Pattern</a>, and method chaining in Rails.<br /><br />The principle is that a subclass doesn&#8217;t really override a superclass&#8217; method, it <em>extends its functionality</em>. Meaning, it typically does something before it, something after it, or something around it. It <em>decorates</em> the method, it doesn&#8217;t replace it.<br /><br />In the example above, it is not really obvious that we are decorating the Employee#something_serious method. That happens to be a side-effect of what we are doing, but it is not obvious at all. Compare and contrast with a little easy AOP magic based on Rails&#8217; object life-cycle style of coding:<br /><pre><code><br />class ProbationaryEmployee &lt; Employee<br />  include EasyAOP<br /><br />  after :something_serious do<br />    self.manager.notify(self, 'did something serious') <br />  end<br />end</code></pre><br /><font size="2">(No, there is no &#8220;EasyAOP&#8221; module. If you are interested in adding AOP to Ruby, consider using the <a href="http://aquarium.rubyforge.org/">Aquarium</a> gem).</font><br /><br />This style of coding makes it obvious that we are attempting to maintain Strict Equivalence. Of course, we can abuse AOP and write advice that breaks our equivalence. 100% enforcement of Strict Equivalence while permitting things like AOP is probably impossible in the compiler. But we can make languages that encourage good programming. I honestly believe that if I have a powerful way to write advice&#8212;like CLOS or AOP&#8212;I could live with <em>never</em> overriding methods. Forget methods being final by default, I think I would be happy with methods always being final if I can have subclasses decorate them.<br /><br /><div class="book"><hr><em><a id="lnx0" name="evtst|a|0262610744" href="http://www.amazon.com/gp/product/0262610744?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262610744"><img src="http://raganwald.github.com/uploaded_images/art_of_mop.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262610744" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a id="lnx1" name="evtst|a|0262610744" href="http://www.amazon.com/gp/product/0262610744?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262610744">The Art of the Metaobject Protocol</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262610744" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is one of the most important books ever written on the subject of building abstractions with objects. The <a href="http://en.wikipedia.org/wiki/Metaobject">Metaobject Protocol</a> is a system for defining your own object semantics, such as the simple aspects described here. While you&rsquo;re learning how to make your programs better in your language, you just might pick up a little Common Lisp. Highly recommended.</em><hr></div>Ruby, of course, does not enforce anything. Java provides some enforcement with its final keyword, but at a cost: subclasses cannot decorate final methods. On the whole, Java is not worse than Ruby for enforcement, because if you don&#8217;t declare a method final, you are no worse off than in Ruby. In Ruby&#8217;s favour, you can actually write things like EasyAOP in a few minutes. Better still, you can tweak it to suit your project and its domain. For Java, you probably need to use a heavyweight AOP framework to do the same thing.<sup><font size="1"><a href="#to_1" name="from_1">1</a></font></sup><br /><br />Or maybe you can chuck all of that and use <abbr title="Common Lisp Object System">CLOS</abbr>. You could do a lot worse.<br /><br /><strong>A Promotion: Manager WAS-AN Employee</strong><br /><br />Wow, that&rsquo;s a lot of <a href="http://en.wikipedia.org/wiki/Flummery">flummery</a> over the statement &ldquo;Manager IS-AN Employee.&rdquo; As we have seen, there are a lot of guarantees that statement makes, especially if you adopt Strict Equivalence. You may not want to make those guarantees. You may not really <em>mean</em> that a manager is an employee, you may mean that a manager has a lot in common with an employee. So what to do?<br /><br />Well, all this trouble started because we said that a Manager IS-AN Employee. What if it isn&#8217;t? What we want is a relationship often called WAS-A. Or it&#8217;s technical name, implementation inheritance. We want to say that a Manager uses the code of an Employee, but it isn&#8217;t to be used where you expect an employee.<br /><br />In C++, you can use private inheritance. The Manager class would obtain all of an Employee&#8217;s members and methods, and it could expose the ones it wanted as part of its own interface:<br /><pre><code><br />class Manager : private Employee { ... }</code></pre><br />A Manager is not an employee. It is its own thing that happens to behave a lot like an employee. In languages like Java that do not provide a WAS-A construct, you can achieve the same thing with delegation. You can say a Manager HAS-AN Employee. It doesn&#8217;t really have one in the sense of a manager having an executive assistant, but it uses an Employee object internally to handle some of its work.<br /><br />This is very much like a manager who has two &#8216;hats.&#8217; It works well if you have been careful to separate things like the implementation of database persistence from the semantic hierarchy of public inheritance. In other words, you didn&#8217;t decide that an Employee IS-AN ActiveRecord::Base.<br /><br />In other words&hellip; If a Manager is <em>not</em> an employee in the true sense of the word but is simply <em>like</em> an employee, we can use object composition to achieve code re-use and communicate to our fellow programmers what managers and employees have in common, without muddying the meaning of IS-A.<br /><br /><strong>What they sought</strong><br /><br />So what have we seen? First, that if you adopt Strict Equivalence, standard inheritance carries a great deal of meaning with it. You can infer that the code in a class describes the behaviour of that class and all of its subclasses: The Employee class describes all employees, even probationary employees and managers. Subclasses extend functionality but never break it.<br /><br />Second, that there are many alternatives to breaking Strict Equivalence, including refactoring the class hierarchy when you need polymorphism and using object composition when you do not. This means that we never <em>need</em> to use inheritance, we only use it when we choose to make guarantees about equivalence.<br /><br />In <a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html" title="Programming conventions as signals">Programming conventions as signals</a>, I advanced the view that when there was more than one way to do something, each should carry a different meaning. And furthermore, when one way is the obvious way to do it, using the non-obvious way was a signal that there was something non-obvious going on.<br /><br />This obviously applies to choosing between class inheritance and object composition. Both can be used to express the idea that two classes or objects have something in common. Class inheritance carries heavyweight baggage along with it about the semantics of IS-A. Object composition does not.<br /><br />Therefore, class inheritance is the more &ldquo;expensive&rdquo; of the two to maintain, because it has the most serious implications and constraints on code. Object composition is cheaper because it makes no guarantees, it is a convenience mechanism.<br /><br />If class inheritance required a pattern and some boilerplate to establish, while object composition was as simple as writing:<br /><pre><code><br />delegate :calculate_annual_bonus, :something_serious, :to => @employee_helper</code></pre><br />&hellip;then there would have been no need for the maxim. Unluckily for us, the popular OO languages make class inheritance <em>cheap</em> to write in code even though it is expensive to maintain, while object composition is expensive to write in code while being cheap to maintain.<br /><br />Thus, we need a maxim to remind ourselves that while class inheritance is seductively easy to write, it should be reserved for those cases where it expresses our actual semantic meaning and where imposing its implications and constraints on our code is going to make things cheaper and not more expensive to maintain.<br /><br />Favor object composition over class inheritance. Now we understand a little of where those six words are heading.<br /><br /><hr><br /><br /><em>Digression: Test-Driven Equivalence</em><br /><br />Consider the requirement that a user of the code be unable to distinguish a subclass from a superclass in a Test-Infected project. You have dozens or even hundreds of tests for each major class. What about all of those unit tests. Should a unit test for the Employee class work when given Manager objects?<br /><br />Hmmm. If a Manager IS-AN Employee, it follows that a Manager can be substituted for an Employee and the tests will pass. If an Employee test breaks when given a manager, we must pick one of two possibilities: First, it is possible that we were wrong to state that a Manager IS-AN Employee. We should have chosen a different structure for our classes.<br /><br /><blockquote>In a test-infected project, the meaning of &#8220;Manager IS-AN Employee&#8221; is external to the Employee class, it is in the tests.</blockquote><br /><br />The second possibility is that the test is inappropriate. We might say that the bonus calculation for an employee is uncertain, that the exact amount of the bonus is not part of the &#8216;spec&#8217; for the Employee class. Therefore, we shouldn&#8217;t have a test that validates the amount of an employee&#8217;s bonus. I can address this point easily: if we can&#8217;t test it, it doesn&#8217;t work, therefore if there shouldn&#8217;t be a test that works for every employee, then there shouldn&#8217;t be code associated with every employee.<br /><br /><div class="book"><hr><em><a id="lnx0" name="evtst|a|0201379430" href="http://www.amazon.com/gp/product/0201379430?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0201379430"><img src="http://raganwald.github.com/uploaded_images/object_design-719894.jpg" border="0" height="160" width="128"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201379430" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a id="lnx0" name="evtst|a|0201379430" href="http://www.amazon.com/gp/product/0201379430?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0201379430">Object Design: Roles, Responsibilities, and Collaborations</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201379430" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> focuses on the practice of designing objects as integral members of a community where each object has specific roles and responsibilities. The authors present the latest practices and techniques of Responsibility-Driven Design and show how you can apply them as you develop modern object-based applications.  <br><br></em><hr></div>So above we stated that according to Strict Equivalence, the code in the Employee class makes a guarantee about all employees. However in a test-infected project, we can take another line. When I say test-infected, I mean specifically that the team has made a commitment to 100% functional coverage in the project, and the team considers the tests to be a form of executable documentation for the code.<br /><br />If this is the case for a project, it follows that the tests for a class must reflect the contractual obligations of that class to its clients. If we write a test that only passes when an Employee&#8217;s annual bonus is such-and-such an amount, that is the amount of bonus for all employees. If we want subclasses of Employee to have their own bonus calculations, we are free to provide a default or base implementation, <em>but we are prohibited from writing a unit test for it</em>.<br /><br />You may think &#8220;That&#8217;s ok, my unit test directly creates an Employee object, it doesn&#8217;t create a Manager object, so the test is not making a guarantee about Managers.&#8221; If you take that line, you have removed all possibility of using the tests to make guarantees about Employees. You cannot say <em>anything</em> about objects that are Employees, because your tests don&#8217;t apply to all employees. This effectively eliminates the IS-A relationship in your test-infected project, because when I am looking at a Manager class, the fact that it derives from Employee tells me <em>nothing</em>, because I can&#8217;t trust any of the Employee tests to tell me something about Managers.<br /><br />Therefore, if you believe that an Employee test does not constrain the behaviour of a Manager object, you are required to duplicate all of the Employee tests that apply to Manager instances in Manager tests. You have moved the problem of what is inherited and what is not inherited from the Employee and Manager classes into your test classes.<br /><br />In a test-infected project, the meaning of &#8220;Manager IS-AN Employee&#8221; is external to the Employee class, it is in the tests. It also conforms to the Liskov Substitution Principle: it demands that whatever the superclass provides its clients, all of its subclasses must also provide. However, it is more relaxed than Strict Equivalence.<br /><br /><hr><ol><li><a name="to_1"></a>There are other approaches: <a href="http://en.wikipedia.org/wiki/Eiffel_%28programming_language%29">Eiffel</a>&#8217;s Design by Contract implementation provides preconditions and post-conditions for methods. As long as a subclass conforms to or narrows its superclass&#8217; post-conditions, and conforms to or widens its superclass&#8217; preconditions, it may override a method.<br /><br />Design by Contract takes the view that the pre-conditions and post-conditions are the contract for a method. Given that understanding of Liskov Equivalence, the language is provides both compiler and run-time enforcement options. Code that adds notification or logging to a superclass&#8217; methods obviously conforms to its post-conditions, so Eiffel permits it without arguing about whether the method should be final or not.<br /><br />Design by Contract also lies in between Plain and Strict Equivalence: Although the Employee class contains code, you cannot rely on it as a guide to what an Employee does. In Eiffel, you can rely on the post-conditions to be enforced, which are typically looser than the method implementation but tighter than a method signature without conditions.<br /><br />[<a href="#from_1">back</a>]</li></ol><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html" title="permanent link">7:54 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			
			    <div class="blogComments">
                                
                                <a name="comments"></a><strong>Comments on &ldquo;<em>IS-STRICTLY-EQUIVALENT-TO-A</em>&rdquo;</strong>:<br/>
						
							<div class="blogComment">
								<a name="4108201671618787868"></a> 				Hi!<BR/><BR/>Nice article. <BR/><BR/>The whole book (Design Patterns...)  is based on 2 principles : "Favor object composition over class inheritance" and "Program to an interface, not an implemetnation". Erich Gamma explains quite well benefits of these principles in this interview:<BR/> http://www.artima.com/lejava/articles/designprinciples.html<BR/><BR/>I think you should read it. <BR/><BR/>I admit, that is-a relationship can have multiple meanings. EG's definition of inheritance is "... type is a subtype of another if its interface contains the interface contains the interface of its supertype".<BR/><BR/>Your views are more based on polymorphism than wider definition of inheritance. <BR/><BR/>Kind regards,<BR/><BR/>Tapio Kulmala<br />
								<div class="byline"><a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html?showComment=1207580400000#c4108201671618787868" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/02519640970304114863" rel="nofollow">TapsaKoo</a> : 11:00 AM</div>

								<span class="item-control blog-admin pid-246593614"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=4108201671618787868" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="7687475451231430983"></a> 				Tapio:<BR/><BR/>Yes, I have read Erich's views. However, "program to an interface, not an implementation" does not apply here.<BR/><BR/>If you want clients to program to your interface, you can simply give them an interface. So why are you giving them a class?<BR/><BR/>The strictly mathematical, compiler-first view of types and inheritance has a pleasing logic to it. But it completely lacks any semantic value.<BR/><BR/>But just because something is easy to define and measure, does not mean it is valuable.<br />
								<div class="byline"><a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html?showComment=1207580760000#c7687475451231430983" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 11:06 AM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=7687475451231430983" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="4183964856810382310"></a> 				Reginald :<BR/><BR/>In your example class inheritance has a valid rationale behind it. What I meant is that, is-a relationship can be implemented using class inheritance or interface inheritance.<BR/><BR/>Composition solves same problems in a different way. For example, your subclass can't inherit from two superclasses. You are forced to use composition and/or interfaces. Every time you use class inheritance, you limit your future options. That's why Erich favors composition over class inheritance.<BR/><BR/>Tapio<br />
								<div class="byline"><a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html?showComment=1207582200000#c4183964856810382310" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/02519640970304114863" rel="nofollow">TapsaKoo</a> : 11:30 AM</div>

								<span class="item-control blog-admin pid-246593614"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=4183964856810382310" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="8001353048641075382"></a> 				<I>Every time you use class inheritance, you limit your future options.</I><BR/><BR/>This is the thesis of the post, although I am justifying that statement with semantic arguments rather than getting too wrapped up in language features.<BR/><BR/>For example, Java provides multiple "interface" inheritance but only single implementation inheritance. But C++, Common Lisp, Ruby and many other OO languages happily provide multiple implementation inheritance.<br />
								<div class="byline"><a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html?showComment=1207582920000#c8001353048641075382" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 11:42 AM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=8001353048641075382" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="5443985805936644706"></a> 				Funny, but I wrote a similar rant not long ago. http://haacked.com/archive/2007/12/11/favor-composition-over-inheritance-and-other-pithy-catch-phrases.aspx<BR/><BR/>Not that I don't agree with favoring composition, I just don't think it's an absolute. "Favor" != "Always".<BR/><BR/>I get skewered now if I use a template method pattern because it requires inheritance.<BR/><BR/>Likewise, a lot of devs don't understand *why* and *when* to favor composition. They don't understand the tradeoffs.<br />
								<div class="byline"><a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html?showComment=1207586700000#c5443985805936644706" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/11732898909434146398" rel="nofollow">Haacked</a> : 12:45 PM</div>

								<span class="item-control blog-admin pid-624939056"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=5443985805936644706" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="3689604514633552629"></a> 				<A HREF="http://haacked.com/archive/2007/12/11/favor-composition-over-inheritance-and-other-pithy-catch-phrases.aspx" REL="nofollow">http://haacked.com/archive/2007/12/11/favor-composition-over-inheritance-and-other-pithy-catch-phrases.aspx<BR/></A><BR/><BR/>Thanks!<BR/><BR/>On one of the "communities," someone had a sarcastic response to the <A HREF="http://cafe.elharo.com/blogroll/final-good/" REL="nofollow">Final == Good</A> article: <I>To boil the article down: OOP is hard. Let's make it as non-object-oriented as possible so that things don't get too complicated!</I><BR/><BR/>I think that&rsquo;s actually correct in a way. OOP actually <I>is</I> hard to get right. Encapsulation is not hard, it is a simplifying principle. But inheritance is seductively easy in the trivial case but hard to get just right in the wild. Thus, the admonition to favour composition.<BR/><BR/>That does&rsquo;t mean we never use it of course. But I am not embarrassed to say that I think inheritance is hard to get right.<br />
								<div class="byline"><a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html?showComment=1207590060000#c3689604514633552629" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 1:41 PM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=3689604514633552629" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="655754103251259080"></a> 				Forgive me if I'm misunderstanding you but I was thinking along the same lines as Tapio re:interfaces.  Could you expand on why they don't apply?  In response you said "Why are you giving them a class?"  If "we give them an interface" instead does it change the problem?<BR/><BR/>Maybe I completely missed your original point because my mind went straight to "use an interface."  To paraphrase JWZ (or whoever first said it) perhaps now I have two problems.<br />
								<div class="byline"><a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html?showComment=1207594800000#c655754103251259080" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/11588921649280002195" rel="nofollow">LeMadChef</a> : 3:00 PM</div>

								<span class="item-control blog-admin pid-1610645593"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=655754103251259080" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="6095219614592663867"></a> 				le Mad Chef:<BR/><BR/>We are in violent agreement!<BR/><BR/>Absolutely use an interface, or an abstract method. Both say the same thing: clients can count on my method signature but not my behaviour.<BR/><BR/>The moment you publish a class, things are more complicated.<br />
								<div class="byline"><a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html?showComment=1207594980000#c6095219614592663867" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 3:03 PM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=6095219614592663867" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="5324404061413550245"></a> 				I know it's something of a toy problem, but it is often better to have a Manager class and a GeneralEmployee class that both extend an abstract Employee, if there is different behavior. It makes things simpler if all real classes live at the leaf level of the hierarchy, although this isn't possible in many re-use situations, which is where inheritance can be the quickest way to get things done.<BR/><BR/>I also find that it can make sense to turn the hierarchy upside down and have the Employee class extend the Manager class. This turns the traditional hierarchy on its head, but is appropriate in many situations where you don't want a Manager object to have access to some methods that an Employee object would- such as the all important writeCode() method, which is properly restricted from Manager objects.<br />
								<div class="byline"><a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html?showComment=1207601280000#c5324404061413550245" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/16098483018096096360" rel="nofollow">Matt M</a> : 4:48 PM</div>

								<span class="item-control blog-admin pid-525906948"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=5324404061413550245" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="7262110817971429433"></a> 				Matt:<BR/><BR/><I>I know it's something of a toy problem, but it is often better to have a Manager class and a GeneralEmployee class that both extend an abstract Employee, if there is different behavior.</I><BR/><BR/>I suspect you&rsquo;d really like the code example in the &ldquo;But&hellip; but&hellip; but&hellip;&rdquo; section :-)<br />
								<div class="byline"><a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html?showComment=1207601460000#c7262110817971429433" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13132345822387028437" rel="nofollow">Reginald Braithwaite</a> : 4:51 PM</div>

								<span class="item-control blog-admin pid-697692447"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=7262110817971429433" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="4637080505108490119"></a> 				Just for fun:<BR/><BR/>class Object<BR/>  def self.delegate(*methods)<BR/>    wrapped_name = "@#{methods.pop[:to].to_s}"<BR/>    <BR/>    methods.each do |meth|<BR/>      define_method(meth) do |*args|<BR/>        instance_variable_get(wrapped_name).send(meth, *args)<BR/>      end<BR/>    end<BR/>  end<BR/>end<BR/><BR/>...though it feels like that should already be implemented somewhere.  Am I reinventing the wheel there?<br />
								<div class="byline"><a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html?showComment=1207744080000#c4637080505108490119" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/02500373813791351590" rel="nofollow">Dan Bernier</a> : 8:28 AM</div>

								<span class="item-control blog-admin pid-70867656"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=4637080505108490119" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
						
					  
					<br /> <p id="postfeeds"></p> <br />
					

					<br /> <br />
					<a href="http://raganwald.github.com/index.html">&lt;&lt; Home</a>
				</div>

			

		


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://weblog.raganwald.com/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://weblog.raganwald.com/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://weblog.raganwald.com/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://weblog.raganwald.com/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://weblog.raganwald.com/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://raganwald.github.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://raganwald.github.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://raganwald.github.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://raganwald.github.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://raganwald.github.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



		<div class="SideBarTitle">Management</div>

		<a href="http://raganwald.github.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://raganwald.github.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://raganwald.github.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://raganwald.github.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://raganwald.github.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://raganwald.github.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://raganwald.github.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://raganwald.github.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://raganwald.github.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://raganwald.github.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://raganwald.github.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://raganwald.github.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://raganwald.github.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://raganwald.github.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://raganwald.github.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://raganwald.github.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_07_01_archive.html">07/08</a> /
		
		
		<br/></p>
		<br/>

		

	</div>





	<div style="visibility: hidden">
		
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>
<html> 
<head>
        
        <title>Haskell, Ruby and Infinity</title>

	<link rel="stylesheet" type="text/css" href="/assets/css/weblog.old.css" />
	<link rel="stylesheet" type="text/css" href="/assets/css/sunburst.css" />



	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>

<body>

	<div id="leftcontent">
			<a href="http://raganwald.github.com/"><img src="http://i.minus.com/ioSY4FTZKVCwz.png"
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/></a><br/>
			
				<div class="DateHeader">Monday, February 26, 2007</div>
			

			<div class="Post"><a name="4134602127458276092">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html" title="permanent link">Haskell, Ruby and Infinity</a></span>
					<div style="clear:both;"></div>Languages like Haskell support <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>. In principle, you only compute what you actually need, everything else just goes away. If you usually need everything you compute, this may seem like a frill: elegant, even interesting, but having little practical importance. I find it is very much like Tail Call Optimization: if you don&rsquo;t have it, you code around it. Often it makes no difference, but from time to time there is a case where your code will be clearer and more maintainable if you express yourself succinctly and let the compiler do the work of making it efficient.<br /><br />This post is a switch from mumbling about <a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">Y Combinators</a> and using trivial cases to explain interesting ideas: I&rsquo;m going to show some actual code I&rsquo;m writing. I apologise in advance if this adds so much background that it obscures the message about lazy evaluation: extremely simplistic examples sometimes work against the argument because it is too easy to think of other ways to accomplish the needed results.<br /><br />I don&rsquo;t apologise <em>at all</em> for the unpolished nature of the code. This isn&rsquo;t a textbook. And besides:<br /><blockquote><br />Anybody can say you can&rsquo;t write. Let no one say you don&rsquo;t.<br /></blockquote><p style="text-align: right;">&mdash;Ken Rand, courtesy of <a href="http://chalain.livejournal.com/">Chalain</a><br /><br /></p><hr /><br /><br />I&rsquo;ve been <a href="http://en.wikipedia.org/wiki/Hacker">hacking</a> some na&iuml;ve code to cluster data sets.<br /><blockquote><br />In computer programming, a hacker is a software designer and programmer who builds elegant, beautiful programs and systems… For some, &ldquo;hacker&rdquo; has a negative connotation and refers to a person who &ldquo;hacks&rdquo; or uses kludges to accomplish programming tasks that are ugly, inelegant, and inefficient.<br /></blockquote><p style="text-align: right;">&mdash;Wikipedia</p>The clustering algorithm requires a very large, fixed set of curves.<sup>1</sup> I wrote the initial curve generation by building a gigantic list of parameter tuples, and then processing the list into records. Once the &ldquo;search space&rdquo; grew beyond a trivial size, the program began to eat enormous amounts of memory. The problem was that I was trying to write the generation code as clearly as possible, and that created a massive thicket of objects that all resided in memory simultaneously.<br /><br /><div style="float: right; width: 240px; margin-left: 10px; font-style: italic; text-align: center; font-size: 80%;"><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Bezier_curve.svg/800px-Bezier_curve.svg.png" height="150" width="240" />The curves being generated are paths composed of cubic beziérs. Each segment on the path requires specifications for four different control points.<br /></div>I rejected the idea of a rewrite into looping, imperative form, I wanted to separate the &ldquo;list comprehension&rdquo; code from the &ldquo;make it run in less than a gigabyte&rdquo; code. Instead, I chose to use lazy evaluation: the principle is that although the code defines a huge data structure that takes up gigabytes, we only actually evaluate things as we need them, and we discard them when we are done, so the total memory footprint for the lazy form is about the same as the memory footprint for an imperative form.<br /><br />The easiest way to perform the refactoring&mdash;besides a rewrite in Haskell&mdash;was to switch all of the arrays I used for a lazy list data structure. A lazy list is a linked list composed of head and tail tuples (known as <a href="http://en.wikipedia.org/wiki/Cons">cons cells</a>). Where a normal linked list holds an element and the rest of the list, a lazy list holds an element and a function for computing the rest of the list (<a href="http://mitpress.mit.edu/sicp/">SICP</a> calls them &ldquo;<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5">streams</a>.&rdquo;)<br /><br />If a modicum of care is taken not to pin objects down, you can build fantastically large lazy lists and process them at will. In fact, lazy lists can be infinitely large if you provide the appropriate function for generating the list<br /><br />For that reason, you should never append one lazy list onto another lazy list. Consider <code>odd = LazyList.unfoldr(1) { |n| n + 2 }</code> and <code>even = LazyList.unfoldr(0) { |n| n + 2 }</code>. If you append <code>odd</code> onto <code>even</code>, the resulting list in theory has both even and odd numbers. But in practice you can never reach the odd numbers because there is an infinite quantity of even numbers at the front of the list.<br /><br />Instead, <code>merge</code> them together to produce a lazy union of the two lists. Merge interleaves alternating elements from each list, so the resulting lazy list contains all the elements of each list, and if you take a finite sample, such as the first 1,000 elements, you get 500 of each. <code>even.merge(odd) => (0 1 2 3 ...)</code>. (Other interesting operations that work with infinite lists include <code>cons</code>, <code>pairwise</code> and <code>product</code>.)<br /><br /><blockquote><br />Any sufficiently complicated Lisp or Ruby program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Haskell.<br /></blockquote><br />My current version of a <code>LazyList</code> class in Ruby is <a href="http://raganwald.com/assets/media/source/lazy_lists.html">here</a>. As soon as I switched from the &ldquo;eager&rdquo; code using arrays to the &ldquo;lazy&rdquo; code using lazy lists, memory use went down and performance went up. Not as much as a switch to imperative (and not even close to writing a better clustering algorithm), but enough that I can move forward.<br /><br />Here is an example of a function using arrays to enumerate choices (<code>distribute(2, 1..4) -&gt; [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]</code>):<br /><br /><pre><code>def distribute choices, range<br />  spots = (range.end - range.begin) + 1<br />  return [] if choices &lt;= 0 || choices &gt; spots<br />  remaining_choices = choices - 1<br />  if remaining_choices == 0<br />    return range.to_a.map { |spot| [spot] }<br />  else<br />    (range.begin..(range.end - remaining_choices)).to_a.inject([]) { |acc, first_spot| acc + (distribute(remaining_choices, (first_spot + 1)..range.end).map { |remaining_distribution| remaining_distribution.unshift(first_spot) }) }<br />  end <br />end<br /></code></pre>And rewritten with lazy lists:<br /><br /><pre><code>def distribute choices, range<br />  spots = (range.end - range.begin) + 1<br />  return LazyList.new() if choices &lt;= 0 || choices &gt; spots<br />  remaining_choices = choices - 1<br />  if remaining_choices == 0<br />    LazyList.from_range(range).map { |spot| LazyList.from_element(spot) }<br />  else<br />    LazyList.from_range(range.begin..(range.end - remaining_choices)).mapr(:merge) do |first_spot|<br />      distribute(remaining_choices, (first_spot + 1)..range.end).map do |remaining_distribution| <br />        LazyList.cons(first_spot, remaining_distribution) <br />      end<br />    end<br />  end <br />end<br /></code></pre>It&rsquo;s almost identical. <code>LazyLists</code> replace arrays, <code>mapr</code> replaces accumulating a list with <code>inject</code>, and <code>cons</code> replaces <code>unshift</code>, but otherwise it&rsquo;s the same code. Mission accomplished: we&rsquo;ve changed the behaviour without having to change the way we express our algorithms. Had we wanted to, we could have supported enough array syntax that Lazy Lists look exactly like arrays, but that isn&rsquo;t necessary.<br /><br />And when running the entire generator, the memory footprint is dramatically lower. For example, this small routine quoted above no longer generates an array of arrays: it generates a structure that can generate the lists when needed. Switching the data structure changes the evaluation behaviour of the generator code: it gets us 80% of having an imperative structure without having to tie the code to the implementation.<br /><br />This is exactly what separation of concerns is all about: <a href="http://raganwald.github.com/2006/12/economizing-can-be-penny-wise-and.html">green code here, yellow code there</a>.<br /><br /><strong>Lazy evaluation is the red pill</strong><br /><br />It&rsquo;s great to make a change to the code&rsquo;s behaviour without changing the way we think about the solution to our problem. But you know what? It isn&rsquo;t <em>interesting</em>. In fact, if lazy optimization was something we needed on a regular basis, we ought to switch to a <a href="http://en.wikipedia.org/wiki/Miranda_%28programming_language%29">language that does it for us</a>. Implementation details ought to be left to libraries, compilers, and virtual machines. That&rsquo;s what they&rsquo;re for.<br /><blockquote><br />A language that doesn&rsquo;t affect the way you think about programming, is not worth knowing.<br /></blockquote><p style="text-align: right;">&mdash;Alan Perlis</p>Now that we hold in our hands a tool for making infinitely long lists, the question to ask is, &ldquo;how does that affect the way we think about generating sample curves?&rdquo;<br /><br />The first thing that comes to mind is to ask why the set of sample curves we generate is finite. It isn&rsquo;t really finite, there are an infinite number of curves. (And not just any infinity, it&rsquo;s Aleph One, the children&rsquo;s book <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&location=http%3A%2F%2Fwww.amazon.com%2FOne-Two-Three-Infinity-Speculations%2Fdp%2F0486256642&amp;amp;amp;tag=raganwald001-20&linkCode=ur2&amp;camp=1789&creative=9325">One Two Three… Infinity</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;amp;amp;l=ur2&o=1" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /> explained that forty years ago.)<br /><p></p><div class="book"><br />  <a href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0521644089"><img src="http://raganwald.github.com/assets/images/old//haskell_school_of_expression.jpg" border="0" /></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;amp;amp;o=1&a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /><br />I&rsquo;m not a Haskell user (yet), but <a href="http://www.amazon.com/gp/product/0521644089?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0521644089">The Haskell School of Expression: Learning Functional Programming through Multimedia</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;amp;amp;o=1&a=0521644089" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /> has received rave reviews and comes with solid recommendations. It&rsquo;s on my <a href="http://www.amazon.com/gp/registry/wishlist/3A2XEHODQK2WP/ref=wl_web/">wish list</a> if you&rsquo;re feeling generous!<br /><br /></div>What we really want is a <em>finite sample</em> of that infinite set of curves. Now let&rsquo;s zoom in and think about a single parameter, the <code>y</code> value for one of the control points on a curve. Let&rsquo;s say it&rsquo;s a rational number between <code>0.0</code> and <code>1.0</code> inclusive. It&rsquo;s relatively easy to generate a list of rationals in that range. Say we generate <code>0.0000...00001</code> (with jillions of zeroes elided: we want the smallest number our computer can represent), followed by <code>0.0000...00002</code> (the second smallest), and so on.<br /><br />If we leave the computer running for a few months or years, we should get all of the numbers between <code>0.0</code> and <code>1.0</code> that our computer can represent. That shouldn&rsquo;t be hard. But even taking into account the finite limitations on a computer&rsquo;s representation, that list is infinitely long.<br /><br /><strong>Useful samples</strong><br /><br />We need to take a finite sample of all of the infinite possibilities in that list.<br /><br />When working with an infinite list, what we want is that the front part of the list, the part we can access before the heat death of the Universe, contains a useful sample. If we were sampling a list like <code>(0.0000...00001 0.0000...00002 0.0000...00003 0.0000...00004 ... )</code> for control points, the first values are not useful at all. We&rsquo;d just get a line along the <code>x</code> access.<br /><br />There are various strategies for generating a more useful list. We could create an infinite list of random values. I&rsquo;ll outline another method below. But the take-away idea is this: we need lists where the most useful values are first. Working with infinite lists encourage us to think of infinitely sized sets of samples, ordered by usefulness.<br /><br />Let&rsquo;s say that when we generate <code>y</code>, we devise a list like <code>(0.0 1.0 0.5 0.75 0.25 ... )</code>. We&rsquo;re successively bisecting the intervals (which is why the library method is called <code>binary_search</code>). We can stop at any time and we have decent distribution. (And we can pipe dream that in the future, we can train our generator to favour points more likely to be useful to us.) That is much more useful!<br /><br />Here&rsquo;s some Lazy List code that does just that: given two seeds and an optional bisection block, it generates an infinite list of values:<br /><br /><pre><code>def binary_search seed1, seed2, &amp;block<br />  bisection_block = block || lambda { |x, y| (x-y)/2 + y }<br />  LazyList.cons(<br />    seed1,<br />    LazyList.new(<br />      seed2,<br />      delay {<br />        bisect(seed1, seed2, &amp;bisection_block)<br />      }<br />    )<br />  )<br />end<br /><br /># infinitely bisects a space, exclusive of the seed values<br /><br />def bisect seed1, seed2, &amp;block<br />  return EMPTY if seed1 == seed2<br />  half = block.call(seed1, seed2)<br />  LazyList.new(<br />    half,<br />    delay {<br />      merge(<br />        bisect(seed1, half, &amp;block),<br />        bisect(half, seed2, &amp;block)<br />      )<br />    }<br />  )<br />end<br /></code></pre>And indeed, <code>LazyList.binary_search(0.0, 1.0) -&gt; (0.0 1.0 0.5 0.75 0.25 ... )</code>.<br /><br /><strong><a href="http://en.wikipedia.org/wiki/Hilbert%27s_hotel">The Grand Hotel</a></strong><br /><br /><div class="book"><a name="evtst|a|0974514055" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.amazon.com/gp/product/0192861611?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0192861611"><img style="" src="http://raganwald.github.com/assets/images/old//satan_cantor_infinity.jpg" alt="Satan, Cantor, and Infinity" border="1" /></a><br /><br /><a href="http://www.amazon.com/gp/product/0192861611?ie=UTF8&tag=raganwald001-20&amp;linkCode=as2&amp;amp;camp=1789&creative=9325&amp;creativeASIN=0192861611">Satan, Cantor, and Infinity and Other Mind-boggling Puzzles</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&amp;amp;amp;o=1&a=0192861611" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1" /> is a five-star introduction to Cantor&rsquo;s work on infinity, including a special treat: a completely different proof that Aleph One is greater than Aleph Zero based on games, very much in the style of Conway&rsquo;s Surreal Numbers. Currently out of print, but <strong>please</strong> get yourself a used copy from a bookseller: you won&rsquo;t be disappointed!<br /><br /></div>What happens when we try to combine two infinite lists? For example, we want a list of <code>(x, y)</code> tuples, generated as the Cartesian Product of our binary search list with itself. If we use a typical breadth-first or depth-first algorithm, we&rsquo;re sunk. We get <code>( (0.0 0.0) (1.0 0.0) (0.5 0.0) (0.75 0.0) (0.25 0.0)... )</code>. That has a nice distribution along one axis but still useless. What we need is a way of combining two infinite lists such that they give us a nice useful sample when we take a finite number of elements off the front.<br /><br />Here&rsquo;s a table describing how the ‘breadth-first&rsquo; algorithm for generating the product of two lists works. Consider two lists of three elements each. In the table below, columns represent one list and rows the other. The numbers represent the order that the product of the lists is generated:<br /><br /><table><tbody><tr><th colspan="3">Breadth-first mapping from elements to integers</th><br />      </tr><tr><td>1</td><td>2</td><td>3</td></tr><br />      <tr><td>4</td><td>5</td><td>6</td></tr><br />      <tr><td>7</td><td>8</td><td>9</td></tr></tbody></table><br />This works fine for finite lists, but as we saw above it is useless for infinite lists. But looking at it in table form is useful. The product of two lists <em>is</em> tabular, the problem with a traditional algorithm is the order that we select elements from the table, not that the elements are tabular. Just as we solved the problem of how to sample <code>y</code> magnitudes by changing the order in which we selected rationals between <code>0.0</code> and <code>1.0</code>, what we need to do with Cartesian Products, what we need to do is select the products in an order that provides useful results.<br /><br />As it happens, there&rsquo;s an order that generates useful finite samples when dealing the product of two infinite lists: Instead of generating rows and appending them to each other, it generates <em>diagonals</em> and <em>merges</em> them with each other. The first diagonal is <code>1, 5, 9</code>. The second is <code>4, 8</code>. The third is <code>2, 6</code>. And so on. The advantage of this algorithm is that if given two infinite lists, it starts in the upper left-hand corner and supplies values, working its way right and down.<sup>2</sup><br /><br />Here&rsquo;re the first four values of the product of two binary searches with each other: <code>[{:x=&gt;0.0, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;1.0}, {:x=&gt;1.0, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;0.5}]</code>. And the next four: <code>[{:x=&gt;1.0, :y=&gt;1.0}, {:x=&gt;1.0, :y=&gt;0.5}, {:x=&gt;0.5, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;0.25}]</code>. And the next eight: <code>[{:x=&gt;0.5, :y=&gt;0.5}, {:x=&gt;0.5, :y=&gt;0.25}, {:x=&gt;0.5, :y=&gt;1.0}, {:x=&gt;1.0, :y=&gt;0.25}, {:x=&gt;0.25, :y=&gt;0.25}, {:x=&gt;0.25, :y=&gt;0.75}, {:x=&gt;0.25, :y=&gt;0.0}, {:x=&gt;0.0, :y=&gt;0.75}]</code>.<br /><br />We can take as many samples as we want, and more sample give us more &ldquo;resolution.&rdquo; We now have the tools we need to get rid of all of the limits and finite combinations and focus on describing what we&rsquo;re trying to generate without intermingling a lot of generating code.<br /><blockquote><br />And I&rsquo;m thinking about eternity<br />Some kind of ecstasy got a hold on me<br /></blockquote><p style="text-align: right;">&mdash;Bruce Cockburn, <a href="http://cockburnproject.net/songs&music/wwtla.html">Wondering Where The Lions Are</a></p>Now that we can generate an infinite list of useful magnitudes, plus we can combine infinite lists in a useful way, we can define an infinite list of sample curves. Here&rsquo;s the exact definition of an infinite list of partial beziérs (there are only three control points because the origin of the beziér is always the terminus of the previous beziér in the curve we are generating):<br /><p></p><pre><code>def sample_cubic_beziers<br />  magnitudes = LazyList.binary_search(0.0, 1.0)<br />  control_points = LazyList.cartesian_product(magnitudes, magnitudes) do |x, y|<br />    { :x => x, :y => y }<br />  end<br />  LazyList.cartesian_product(control_points, control_points, control_points) do |p1, p2, p3|<br />    {<br />      :p1 => p1,<br />      :p2 => p2,<br />      :p3 => p3<br />    }<br />  end<br />end<br /></code></pre>That&rsquo;s really simple, and really easy to understand.<sup>3</sup> The domain-specific code that defines a cubic Bezi&eacute;r is concise and readable. And the infrastructure code that handles combinatorics is shunted away out of sight where it doesn&rsquo;t clutter up our thinking.<br /><br />So what have we seen?<br /><ol><br /><li>Lazy evaluation solved a performance problem without needing an extensive rewrite of our generation code;</li><br /><li>Taking the red pill, infinite lists allowed us to radically simplify the original code.</li><br /></ol>Are there some opportunities to steal an idea like lazy evaluation from other languages and use them to simplify your code?<br /><br /><hr /><br /><ol><li>The data is a set of <code>(x,y)</code> tuples where <code>x</code> is time and <code>y</code> is a magnitude. The effort remaining in a <a href="http://www.mountaingoatsoftware.com/sprint_backlog">sprint backlog</a> is an example of this kind of data set. I need a function that computes the distance between any two data sets. I already have a function that computes the distance between a curve through the <code>xy</code> space and a data set, so if I build a lot of curves and then take the distance between each curve and each data set, I can find the distance between pairs of data sets by searching for the curve with the lowest total distance.<br /><br />This operation is On<sup>2</sup>, but that&rsquo;s why we invented distributed processing. Also, this operation is done infrequently relative to operations making use of the clusters, something like Google&rsquo;s indexing being far less frequent than searching Google. And of course, when my MacBook overheats and burns its way through my desk, I can come back and replace the brute force operation with something more intelligent.<br /><br />Well, all this requires generating the sample curves. I have code that makes curves out of Beziérs, provided I supply coördinates for the control points. the curves are actually <code>ActiveRecord</code> models. So all I needed was some simple code that generates all of the possible combinations and then write them to the database. It&rsquo;s the kind of thing candidates write in job interviews where employers actually care about their stone cutting skills.</li><br /><li>This problem is congruent to the proof that the set of all points on a plane is the same size as the set of all points in a line.</li><br /><li>And it could be simpler yet: a &ldquo;list comprehensions&rdquo; DSL for lazy lists <strike>is on the wish list</strike> <a href="http://raganwald.github.com/2007/03/approach-to-composing-domain-specific.html#lcir">would make things far more readable</a>.</li><br /></ol><div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/archives/labels/lispy.html">lispy</a>, <a rel='tag' href="http://raganwald.github.com/archives/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html" title="permanent link">1:49 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			
			    <div class="blogComments">
                                
                                <a name="comments"></a><strong>Comments on &ldquo;<em>Haskell, Ruby and Infinity</em>&rdquo;</strong>:<br/>
						
							<div class="blogComment">
								<a name="221498126614359727"></a> 				That's a really nice way to search a parameter space!<BR/><BR/>In code with lots of nested list generators, the trick is to make sure that all the intermediate lexical scopes can be garbage-collected. And in a really tricky example (such as yours, here), that can sometimes be challenging.<BR/><BR/>For an example of what can go wrong, see <A HREF="http://users.aber.ac.uk/afc/papers/ClareKingPADL.pdf " REL="nofollow">Data Mining the Yeast Genome in a Lazy Functional Language</A>. They implemented a very sophisticated algorithm in days, and then spent a couple of weeks getting their heap size under control.<BR/><BR/>The usual solution in Haskell is to define a small number of well-understood list-walking functions, and define everything in terms of them. If, for example, you can write everything in terms of 'fold', you can automatically rule out various pathological behaviors.<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html?showComment=1172520060000#c221498126614359727" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon anon-comment-icon"><img src="http://www.blogger.com/img/anon16-rounded.gif" alt="Anonymous" style="display:inline;" /></span>&nbsp;<a href="http://www.randomhacks.net/" rel="nofollow">emk</a> : 3:01 PM</div>

								<span class="item-control blog-admin pid-1482585217"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=221498126614359727" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="7006505831523520160"></a> 				<I>if lazy optimization was something we needed on a regular basis, we ought to switch to <B>a language that does it for us</B>.</I><BR/><BR/>Interesting to see that link to ye olde Miranda, also note "CLEAN is by default a lazy language"<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html?showComment=1172523600000#c7006505831523520160" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/05398229396333413000" rel="nofollow">Isaac Gouy</a> : 4:00 PM</div>

								<span class="item-control blog-admin pid-51843297"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=7006505831523520160" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="2461864511671575671"></a> 				I used lazy techniques in the Notes Formula Language runtime as well. During formula startup, it does a semantic analysis of the runtime trees and figures out which expressions and subexpressions (tree nodes) are referentially transparent.<BR/><BR/>It then does partial evaluations of the trees, executing only branches that have side effects and lazily executes all referentially transparent subbranches.<BR/><BR/>The cool thing is expressions that evaluate and assign to a variable can instead be partially executed and the remaining referentially transparent computations are done only when the variable is later referenced. Also the engine can figure out "constant" expressions using the same mechanism, and cache the expression results for subsequent evaluations.<BR/><BR/>This might sound rather complicated, but the algorithm is simple to understand and the formula can be analyzed in O(N) time (N being the number of nodes in the parsed formula tree), so it incurs very little overhead. In the Notes formula engine, the analysis happens during the building of the runtime trees.<BR/><BR/>I understand most SQL interpreters do something similar (as I now work for MySQL, I should know more about all that soon).<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html?showComment=1172605320000#c2461864511671575671" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/07299732457242903370" rel="nofollow">Damien</a> : 2:42 PM</div>

								<span class="item-control blog-admin pid-575250849"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=2461864511671575671" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
							<div class="blogComment">
								<a name="8968935777551156213"></a> 				I used lazy techniques in the Notes Formula Language runtime as well. During formula startup, it does a semantic analysis of the runtime trees and figures out which expressions and subexpressions (tree nodes) are referentially transparent.<BR/><BR/>It then does partial evaluations of the trees, executing only branches that have side effects and lazily executes all referentially transparent subbranches.<BR/><BR/>The cool thing is expressions that evaluate and assign to a variable can instead be partially executed and the remaining referentially transparent computations are done only when the variable is later referenced. Also the engine can figure out "constant" expressions using the same mechanism, and cache the expression results for subsequent evaluations.<BR/><BR/>This might sound rather complicated, but the algorithm is simple to understand and the formula can be analyzed in O(N) time (N being the number of nodes in the parsed formula tree), so it incurs very little overhead. In the Notes formula engine, the analysis happens during the building of the runtime trees.<BR/><BR/>I understand most SQL interpreters do something similar (as I now work for MySQL, I should know more about all that soon).<br />
								<div class="byline"><a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html?showComment=1172605380000#c8968935777551156213" title="permanent link">#</a> posted by <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://www.blogger.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/07299732457242903370" rel="nofollow">Damien</a> : 2:43 PM</div>

								<span class="item-control blog-admin pid-575250849"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=7618424&postID=8968935777551156213" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
							</div>
						
						
					  
					<br /> <p id="postfeeds"></p> <br />
					

					<br /> <br />
					<a href="http://raganwald.github.com/index.html">&lt;&lt; Home</a>
				</div>

			

		


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://raganwald.com/assets/media/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://raganwald.com/assets/media/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://raganwald.com/assets/media/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://raganwald.com/assets/media/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://raganwald.com/assets/media/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://raganwald.github.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://raganwald.github.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://raganwald.github.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://raganwald.github.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://raganwald.github.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



		<div class="SideBarTitle">Management</div>

		<a href="http://raganwald.github.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://raganwald.github.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://raganwald.github.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://raganwald.github.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://raganwald.github.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://raganwald.github.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://raganwald.github.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://raganwald.github.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://raganwald.github.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://raganwald.github.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://raganwald.github.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://raganwald.github.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://raganwald.github.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://raganwald.github.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://raganwald.github.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://raganwald.github.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_07_01_archive.html">07/08</a> /
		
		
		<br/></p>
		<br/>

		

	</div>





	<div style="visibility: hidden">
		
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>
<html> 
<head>
        
        <title>raganwald: 12/07</title>

	<link rel="stylesheet" type="text/css" href="/assets/css/weblog.old.css" />
	<link rel="stylesheet" type="text/css" href="/assets/css/sunburst.css" />

	<!-- Meta Information --> 
	<!-- put "BlogMetaData" between angle-dollar and dollar angle  to restore defaults -->

	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="MSSmartTagsPreventParsing" content="true" />
	<meta name="generator" content="Blogger" />

	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts + Links(Atom)" href="http://feeds.raganwald.com/raganwald" />
	<!-- <link rel="alternate" type="application/rss+xml" title="Raganwald Posts + Links (RSS 2.0)" href="http://feeds.raganwald.com/raganwald" /> -->
	<link rel="alternate" type="application/atom+xml" title="Raganwald Posts Only (Atom)" href="http://feeds.raganwald.com/raganwald_articles" />
	<link rel="alternate" type="application/atom+xml" title="Raganwald on Twitter (Atom, experimental)" href="http://twitter.com/statuses/user_timeline/14165291.atom" />

	<link rel="service.post" type="application/atom+xml" title="Raganwald" href="https://www.blogger.com/atom/7618424" />
	<link rel="service.post" type="application/atom+xml" title="Raganwald (Atom 1.0)" href="http://www.blogger.com/feeds/7618424/posts/full" />

	<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.blogger.com/rsd.g?blogID=7618424" />



    <link rel="openid.server" href="http://www.myopenid.com/server " />
    <link rel="openid.delegate" href="http://reginald.braithwaite.myopenid.com/" />
    <meta http-equiv="X-XRDS-Location" content="http://reginald.braithwaite.myopenid.com/xrds" />




	<style type="text/css">
	@import url("http://www.blogger.com/css/blog_controls.css");
	@import url("http://www.blogger.com/dyn-css/authorization.css?blogID=7618424");
	</style>

	<!-- /Meta Information -->
</head>

<body>

	<div id="leftcontent">
			<img src="http://i.minus.com/ioSY4FTZKVCwz.png"
			width="350" height="150" border="0" alt="raganwald" title="raganwald 2008" align="middle"/><br/>
<!--
<div style="background-color:black; text-align: center; color: white; padding: 10px 10px 10px 10px;">
<p><font size="+1">Arthur C. Clarke</font><font size="-1">, 1917&thinsp;&ndash;&thinsp;2008
<br/>&ldquo;If we have learned one thing from the history of invention and discovery,
<br/>it is that, in the long run&mdash;and often in the short one&mdash;the most daring prophecies seem laughably conservative.&rdquo;</font>
</p></div>
-->
		
			
				<div class="DateHeader">Monday, December 31, 2007</div>
			

			<div class="Post"><a name="3953211191709790913">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/blogging-is-hard-lets-mine-larry-wall.html" title="permanent link">Blogging is Hard, Let's Mine Larry Wall for Quotes</a></span>
					<div style="clear:both;"></div>All quotes are from <a href="http://www.perl.com/lpt/a/997" title="Perl.com: Programming is Hard, Let's Go Scripting...">Programming is Hard, Let&#8217;s Go Scripting&#8230;</a> by Larry Wall, Perl&#8217;s creator:<br /><br /><strong>what is scripting?</strong><br /><br /><blockquote>When we call something a scripting language, we&#8217;re primarily making a linguistic and cultural judgement, not a technical judgement.</blockquote><br /><blockquote>For a given dimension X, different scripting languages make different choices, set the knob at different locations.<br />  <ul><li>You can&#8217;t even think about X!</li><li>There&#8217;s only one way to do X!</li><li>There&#8217;s more than one way to do X!</li><li>There are too many ways to do X!</li></ul></blockquote><br /><strong>programming languages</strong><br /><br /><blockquote>I started out as a BASIC programmer. Some people would say that I&#8217;m permanently damaged. Some people are undoubtedly right.<br />  <br />I had a college buddy I did pair programming with. We took a compiler writing class together and studied all that fancy stuff from the dragon book. Then of course the professor announced we would be implementing our own language, called PL/0. After thinking about it a while, we announced that we were going to do our project in BASIC. The professor looked at us like were insane.<br />  <br />Nobody else in the class was using BASIC. And you know what? Nobody else in the class finished their compiler either. We not only finished but added I/O extensions, and called it PL 0.5. That&#8217;s rapid prototyping.</blockquote><br /><blockquote>Is LISP a candidate for a scripting language? While you can certainly write things rapidly in it, I cannot in good conscience call LISP a scripting language. By policy, LISP has never really catered to mere mortals.<br />  <br />And, of course, mere mortals have never really forgiven LISP for not catering to them.<br />  <br />I&#8217;ve always admired Tcl&#8217;s delegational model of semantics. But it fell into the same trap as LISP by expecting everyone to use the One True Syntax. Speaking of the One True Syntax: I don&#8217;t really know much about Python. I only stole its object system for Perl 5. I have since repented.</blockquote><br /><blockquote>PHP takes the worse-is-better approach to dazzling new depths</blockquote><br /><strong>postmodernism</strong><br /><br /><blockquote>I read [the word "text"] from a postmodern perspective. Of course, the term Postmodern is itself context-sensitive. Some folks think Postmodernism means little more than the Empowerment of the Vulgar. Some folks think the same about Perl. But I take Postmodernism to mean that a Text, whether spoken or written, is an act of communication requiring intelligence on both ends, and sometimes in the middle too. I don&#8217;t want to talk to a stupid computer language. I want my computer language to understand the strings I type.</blockquote><br /><blockquote>Human languages therefore differ not so much in what you can say but in what you must say. In English, you are forced to differentiate singular from plural. In Japanese, you don&#8217;t have to distinguish singular from plural, but you do have to pick a specific level of politeness, taking into account not only your degree of respect for the person you&#8217;re talking to, but also your degree of respect for the person or thing you&#8217;re talking about.<br />  <br />So languages differ in what you&#8217;re forced to say. Obviously, if your language forces you to say something, you can&#8217;t be concise in that particular dimension using your language. Which brings us back to scripting.</blockquote><br /><blockquote>I like it when most of the actual words are those chosen by the programmer to represent the problem at hand. I don&#8217;t like to see words used for mere syntax. Such syntactic functors merely obscure the real words. That&#8217;s one thing I learned when I switched from Pascal to C. Braces for blocks. It&#8217;s just right visually.<br />  <br />Actually, there are languages that do it even worse than COBOL. I remember one Pascal variant that required your keywords to be capitalized so that they would stand out. No, no, no, no, no! You don&#8217;t want your functors to stand out. It&#8217;s shouting the wrong words: <code>IF! foo THEN! bar ELSE! baz END! END! END! END!</code></blockquote><br /><strong>worse is better</strong><br /><br /><blockquote>Classes in Java are closed, which is one of the reasons Java can run pretty fast. In contrast, Ruby&#8217;s classes are open, which means you can add new things to them at any time. Keeping that option open is perhaps one of the reasons Ruby runs so slow. But that flexibility is also why Ruby has Rails.</blockquote><br /><blockquote>Multiple dispatch is like democracy. It&#8217;s the worst way to do late binding, except for all the others.</blockquote><br /><blockquote>Among the generalists, the conventional wisdom is that the worse-is-better approach is more adaptive. Personally, I get a little tired of the argument: My worse-is-better is better than your worse-is-better because I&#8217;m better at being worser! Is it really true that the worse-is-better approach always wins?<br /><br />With Perl 6 we&#8217;re trying to sneak one better-is-better cycle in there and hope to come out ahead before reverting to the tried and true worse-is-better approach. Whether that works, only time will tell.</blockquote><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/blogging-is-hard-lets-mine-larry-wall.html" title="permanent link">2:56 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, December 30, 2007</div>
			

			<div class="Post"><a name="7915620493751315867">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/at-last-researchers-finally-explain-why.html" title="permanent link">At Last! Researchers explain why there are so many weblogs about programming and programming languages</a></span>
					<div style="clear:both;"></div><blockquote>The <a href="http://en.wikipedia.org/wiki/Dunning-Kruger_effect" title="Dunning-Kruger effect - Wikipedia, the free encyclopedia">Dunning-Kruger effect</a> is the phenomenon wherein people who have little knowledge think that they know more than others who have much more knowledge.</blockquote><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/at-last-researchers-finally-explain-why.html" title="permanent link">2:17 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, December 28, 2007</div>
			

			<div class="Post"><a name="5473500335651384097">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/why-rubinius-matters-to-rubys-future.html" title="permanent link">Why Rubinius Matters to Ruby's Future</a></span>
					<div style="clear:both;"></div>I am a long-time fan of <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html" title="The significance of the meta-circular interpreter">self-hosted languages</a>. In that post I listed the reasons I thought that a language should be mostly or entirely written in itself. Here&rsquo;s another reason writing a language in itself is important: If a language&#8217;s core libraries and frameworks are written in that language, it is possible for every programmer to improve on them.<br /><br />Ruby&#8217;s core libraries are written in C. Here&#8217;s the source for Ruby&#8217;s collect method:<pre><code><br />/*<br /> *  call-seq:<br /> *     array.collect {|item| block }  -> an<em>array<br /> *     array.map     {|item| block }  -> an</em>array<br /> * <br><br /> *  Invokes <i>block</i> once for each element of <i>self</i>. Creates a <br /> *  new array containing the values returned by the block.<br /> *  See also <code>Enumerable#collect</code>.<br /> * <br><br /> *     a = [ &#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221; ]<br /> *     a.collect {|x| x + &#8220;!&#8221; }   #=> [&#8220;a!&#8221;, &#8220;b!&#8221;, &#8220;c!&#8221;, &#8220;d!&#8221;]<br /> *     a                          #=> [&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221;]<br /> */<br />static VALUE<br />rb_ary_collect(ary)<br />    VALUE ary;<br />{<br />    long i;<br />    VALUE collect;<br /><br />    if (!rb_block_given_p()) {<br />    return rb_ary_new4(RARRAY(ary)-&gt;len, RARRAY(ary)-&gt;ptr);<br />    }<br /><br />    collect = rb_ary_new2(RARRAY(ary)-&gt;len);<br />    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {<br />    rb_ary_push(collect, rb_yield(RARRAY(ary)-&gt;ptr[i]));<br />    }<br />    return collect;<br />}<br /></code></pre><br />Perhaps you like working with Haskell-style fold and <a href="http://raganwald.github.com/2007/11/really-useful-anamorphisms-in-ruby.html" title="Really useful anamorphisms in Ruby">unfold</a> rather than the Smalltalk-style collect, select, and detect. No problem, you can hack your own in Ruby, like this:<pre><code><br />class Object<br />  def unfold options = {}, &amp;incrementor<br />    return [] unless options[:while].nil? || options[:while].to_proc.call(self)<br />    transformed = options[:map] &amp;&amp; options[:map].to_proc[self] || self<br />    return [transformed] if options[:to] &amp;&amp; options[:to].to_proc.call(self)<br />    incrementor.call(self).unfold(options, &amp;incrementor).unshift(transformed)<br />  end<br />end</code></pre><br />One hitch: your fold and unfold are hundreds of times slower than Ruby&#8217;s built-in-C methods and classes. It reminds me of Newton programming. Apple gave us a really cool language&#8212;NewtonScript&#8212;for writing applications. Except, the built-in applications were written in C, and the C compiler was only for Apple engineers.<br /><br />The good news about Ruby is that you can write your own classes in C if you want to. But that is a significant barrier to entry for many programmers, shrinking the available pool of programmers who will enhance the language.<br /><br />Having core libraries in C is a great choice for implementing a language that is to be used for other things like building web applications. But it is not a great choice for a language that is to be used to build other languages. And &#8220;building other languages&#8221; is <em>exactly</em> what Bottom-Up Programming or Meta-Linguistic Abstractions are all about. In other words, writing the core libraries in C is not a great choice for a language where programmers write their own abstractions. <br /><br />Now for many things, the speed penalty of writing your own abstractions in Ruby is negligible. But not everything. So there is always going to be this class of things&#8212;and I think collection manipulation is one of those things&#8212;where you need to be able to write stuff that is as good as what comes out-of-the-box.<br /><br />If new stuff is an order of magnitude slower, you might be able to use it for non-critical things, but your chances of persuading anyone else to use it are very low. Which means that the language <em>as a whole</em> progresses slowly because real progress can only happen in areas where performance doesn&#8217;t matter. Like database-bound web applications.<br /><br />Having an implementation where the built-in stuff is on the same footing as your stuff opens up the doors for actual progress. It forces the language itself to be Good Enough, and it makes it possible for every Ruby programmer to improve the language.<br /><br /><strong>what we can learn from java, whoops smalltalk</strong><br /><br />Java has this incredibly powerful and popular IDE, Eclipse. It is so powerful that many people feel it is impossible to write production Java code without it. Why is it so powerful?<br /><br />One of the major reasons it is both powerful and popular is the availability of plug ins. It seems to support the language, UML diagrams, source code control, and everything up to (I&rsquo;m pretty sure) time tracking for client billing. Naturally, the plug ins are written in Java, just like the almost all of the built-in functionality.<br /><br />Clara Creative can write her own plug in and it won&rsquo;t be a second-class citizen. And since it is a tool for Java programmers, Clara Creative already knows how to write plug ins, she doesn&rsquo;t need to drop into another language.<br /><br />Wow, that is neat. And it does help explain why Eclipse has so many plug ins, and why they are popular: there is no low-level language barrier, and they all on an equal footing with each other.<br /><br />This shouldn&rsquo;t surprise you. <a href="http://en.wikipedia.org/wiki/IBM_VisualAge">Eclipse evolved from IBM VisualAge Micro</a>, which was written by Smalltalk programmers in Smalltalk. And of course, Smalltalk is a language where almost everything is written in Smalltalk itself. Smalltalk programmers expect to be able to extend the language and environment without penalty.<br /><br />In the end, the choice of whether to implement core features in C or Ruby will always be difficult. The temptation to optimize for speed will always be strong, especially when the language is fighting for mind share. But extensibility and variety is also a win, and Ruby fights with its libraries and features as much as with its performance.<br /><br />Perhaps we won&#8217;t all be using fold and unfold instead of collect, select, and detect. But if we aren&#8217;t, it ought to be because we prefer the originals, not because the replacements are crippled in comparison, or because the kind of person who likes inventing new tools prefers to write them in Ruby instead of in C.<br /><hr/><br />I&#8217;m looking forward to hearing more from the <a href="http://blog.fallingsnow.net/category/rubinius/" title="rubinius &laquo; evan.musing &lt;&lt; current">Rubinius</a> team. I really think they hold the key to the future. Thanks, Ezra, for your comment.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/archives/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/why-rubinius-matters-to-rubys-future.html" title="permanent link">5:05 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			

			<div class="Post"><a name="1575164859623005484">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/something-in-ruby-that-bit-me-at-work.html" title="permanent link">Something in Ruby that bit me at work today</a></span>
					<div style="clear:both;"></div>The methods :class and :dup are a bit of a leaky abstraction when used in combination with an object&rsquo;s <a href="http://ola-bini.blogspot.com/2006/09/ruby-singleton-class.html">Singleton Class</a>:<br /><pre><code><br />  class Marx<br />    def jokes (laughs)<br />      laughs * 2<br />    end<br />  end<br /><br />  groucho = Marx.new<br />  chico = groucho.dup<br /><br />  puts "#{groucho.jokes(10)} == #{chico.jokes(10)}"<br /><br />  def groucho.jokes (laughs)<br />    laughs / 2<br />  end<br /><br />  harpo = groucho.dup<br /><br />  puts "#{groucho.jokes(10)} != #{harpo.jokes(10)}"<br />  puts "...but #{harpo.jokes(10)} == #{chico.jokes(10)}"<br />  puts "because Groucho is still considered a #{groucho.class}"</code></pre><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/something-in-ruby-that-bit-me-at-work.html" title="permanent link">2:16 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, December 27, 2007</div>
			

			<div class="Post"><a name="1242084701441810451">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/if-you-cannot-change-your-language.html" title="permanent link">If you cannot change your language, change your language</a></span>
					<div style="clear:both;"></div><blockquote>You want to strive to make sure every single line of code has some value or meaning to the programmer. Programming languages are for humans, not machines. If you have code that looks like it doesn&#8217;t do anything useful, is hard to read, or seems tedious, then chances are good that Python has some language feature that will let you remove it.</blockquote><div>&#8212;Ryan Tomayko, <a href="http://tomayko.com/articles/2005/01/20/getters-setters-fuxors" title="Getters/Setters/Fuxors">Getters/Setters/Fuxors</a></div><br />Generalizing this, I would say:<br /><br /><blockquote>You want to strive to make sure every single line of code has some value or meaning to the programmer. Programming languages are for humans, not machines. If you have code that looks like it doesn&#8217;t do anything useful, is hard to read, or seems tedious, then introduce an <a title="Abbreviation, Accidental Complexity, and Abstraction" href="http://raganwald.github.com/2007/07/abbreviation-accidental-complexity-and.html">abstraction</a> that will let you remove it.<br /><br />If your language&#8217;s mechanisms for abstracting away accidental complexity are so laborious that you cannot remove the useless, the hard to read, and the tedious from your programs without introducing code that is even more useless, harder to read, and more tedious to your framework, then change languages.</blockquote><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/if-you-cannot-change-your-language.html" title="permanent link">4:10 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, December 24, 2007</div>
			

			<div class="Post"><a name="7886675914622385832">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/groucho-marx-on-programming-flame-wars.html" title="permanent link">Groucho Marx on Programming Flame Wars</a></span>
					<div style="clear:both;"></div><blockquote>Years ago, I tried to top everybody, but I don&rsquo;t anymore. I realized it was killing conversation. When you&rsquo;re always trying for a topper you aren&rsquo;t really listening. It ruins communication.</blockquote><div>&mdash;Julius &ldquo;Groucho&rdquo; Marx<br /><font size=-2>as quoted in <em>What Color is Your Paradigm: Thinking for Shaping Life and Results</em> (2003) by Howard Edson, p. 184. Source: <a href="http://en.wikiquote.org/wiki/Groucho_Marx">WikiQuote</a></font></div><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/groucho-marx-on-programming-flame-wars.html" title="permanent link">7:12 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, December 23, 2007</div>
			

			<div class="Post"><a name="936569742442545582">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/paul-w-homer-on-nature-of-simple.html" title="permanent link">Paul W. Homer on The Nature of Simple</a></span>
					<div style="clear:both;"></div><blockquote>Back in [my VMS] days, we could place as many C functions as we wanted into individual files. One developer, while working, came up with the philosophy of sticking one, and only one function into each file. This, he figured was the &#8216;simplest&#8217; way to handle the issue. A nice side effect was you could list out all of the files in a directory and because the file name is the same as the function name, this produced a catalog of all of the available functions. And so off he went.<br />  <br />  At first this worked well. In a small or even medium system, this type of &#8216;simplified&#8217; approach can work, but it truly is simplified with respect to so few variables that we need to understand how quickly it goes wrong. At some point, the tide turned, probably when the system had passed a hundred or so files, but by the time it got to 300 it was getting really ugly&#8230;<br />  <br />  Although many of the functions were related, the order in the &#8216;dir&#8217; was not. Thus similar functions were hard to place together. All of this was originally for a common library, but as it got larger it became hard to actually know what was in the library. It became less and less likely that the other coders were using the routines in common. Thus the &#8216;mechanics&#8217; of accessing the source became the barrier to prevent people from utilizing the source, which was rapidly diminishing the usefulness and work already put into it&#8230;<br />  <br />  By now, most developers would easily suggest just collapsing the 300 files into 12 that were ordered by related functions. With each file containing between 10 and 30 functions&#8212;named for the general type of functions in the file, such as date routine &#8212;navigating the directory and paging through a few files until you find the right function is easy. 12 files vs. 300 is a huge difference.<br />  <br />  Clearly the solution of combining the functions together into a smaller number of files is fairly obvious, but the original programmer refused to see it. He had &#8220;zoomed&#8221; himself into believing that one-function-per-file was the &#8216;simplest&#8217; answer. He couldn&#8217;t break out of that perspective. In fact, he stuck with that awkward arrangement right up to the end, even when he was clearly having doubts. He just couldn&#8217;t bring himself to &#8216;complicate&#8217; the code.</blockquote><div>&#8212;Paul W. Homer, <a href="http://theprogrammersparadox.blogspot.com/2007/12/nature-of-simple.html">The Nature of Simple</a></div><br />Just one thought to ponder: sometimes what is simple at one scale is not simple at another. You can use this argument both ways when thinking about idioms and programming paradigms.<br /><br />You could argue that things like <a href="http://raganwald.github.com/2007/11/what-if-powerful-languages-and-idioms.html" title="What if powerful languages and idioms only work for small teams?">functional programming techniques don&rsquo;t scale to larger teams</a>. You could also argue that sticking to the lowest-common-denominator patterns works fine for small projects, but you need to employ higher levels of abstraction if you are going to keep a large application with many maintainers flexible and cost-effective.<br /><br />Hmmm.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/paul-w-homer-on-nature-of-simple.html" title="permanent link">11:45 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Saturday, December 22, 2007</div>
			

			<div class="Post"><a name="45409711461217309">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/pouring-water-back-into-flask.html" title="permanent link">Pouring water back into the flask</a></span>
					<div style="clear:both;"></div><blockquote>The University of Flatland uses a novel two-part practical test to determine whether Comp. Sci. undergraduates should be steered into practical programming or abstract theory streams. In the first part, the students are given a beaker, a bunsen burner, a stand, and a flask of water. They are told to boil water. Naturally, they fill the beaker, place it on the stand, light the burner, and are queued up to perform the second test.<br />  <br />  In the second part of the test, they are presented with a beaker of water sitting on a stand over a Bunsen burner, and an empty flask. Most of the students light the burner and are led away to begin their studies in programming. But a precious few disassemble the apparatus and pour the water back into the flask, <u>reducing it to a problem they have already solved</u>. They are led away to begin the long road to their Ph.D. in Lisp, Recursion, and Category Theory.</blockquote><br />Like most the jokes I retell, this is not particularly funny. But let&#8217;s talk about &ldquo;Design Patterns&rdquo; and then come back to it. Design patterns allow developers communicate their intentions to each other with a common vocabulary.<br /><br />This makes sense. If I create a Flyweight and I want to describe it to another developer, having a word for it, along with a common understanding of what problem a flyweight solves, streamlines our communication. Design patterns in that light are jargon, a sub-language used by specialists to discuss their speciality.<br /><br />If it stopped right there, you would have the design patterns invented by Christopher Alexander and articulated in the incredible book <a href="http://www.amazon.com/gp/redirect.html?ie=UTF8&amp;location=http%3A%2F%2Fwww.amazon.com%2FPattern-Language-Buildings-Construction-Environmental%2Fdp%2F0195019199&amp;tag=raganwald001-20&amp;linkCode=ur2&amp;camp=1789&amp;creative=9325">A Pattern Language</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=ur2&amp;o=1" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />.<br /><br />But it doesn&#8217;t stop there. In certain programming cultures, people consider Design Patterns to be a core set of practices that must be used to build software. It isn&#8217;t a case of <em>when</em> you need to solve a problem  <em>best addressed</em> by a design pattern, <em>then</em> use the pattern and refer to it by name. It&#8217;s a case of <em>always</em> use design patterns. If your solution doesn&#8217;t naturally conform to patterns, refactor it to patterns.<br /><br />Is this madness? Yes&#8230; And no&#8230;<br /><br />Consider <a href="http://en.wikipedia.org/wiki/Scheme_%28programming_language%29" title="Scheme (programming language) - Wikipedia, the free encyclopedia">Scheme</a>. Everything in Scheme is built out of just <em>five</em> primitive &#8220;special forms.&#8221; It is positively <a href="http://raganwald.github.com/2007/10/until-you-understand-how-forth-is.html" title="Until you understand how FORTH is written, youâ€™ll have only a very superficial understanding of how to use it.">Forth-like</a> in its economy of power. So it is clearly possible to build very powerful programs out of five primitives. So why not build programs out of thirty-five patterns?<br /><br />While we digest that, back to the joke. Scheme programmers are clearly the impractical theoreticians, aren&#8217;t they? Reducing everything to their five special forms that they have already solved and what-not. While the practical programmers look for the simple, direct way to boil water.<br /><br /><blockquote>When you take a problem with a straightforward solution and make it more complex by re-expressing it as a combination of patterns, you are pouring the water back into the flask.</blockquote><br />So what do we make of the &#8220;everything should be one of these thirty-five standard design patterns&#8221; argument? I make of it the same thing that I make of the joke. It is clearly possible. But when you take a problem with a straightforward solution outside of the core patterns in one book and make it more complex by re-expressing it as a combination of patterns, you are pouring the water back into the flask.<br /><br />The argument that &#8220;everything should be one of these thirty-five standard design patterns&#8221; is an argument that fits the theoretician, not the pragmatist. It is motivated by a desire for building very complicated things out of very simple parts. That is possible. But it is a fallacy to believe that simplifying the constituent parts simplifies the software. Like boiling water, you can make it <em>more complex</em> when you place the pattern ahead of the solution.<br /><br />Of course there are arguments ad nauseam about standardization and readability. But I have this strong suspicion that at the core of it, the motivation is a belief that the world should be reduced to a simple set of easy-to-understand things that can be combined and recombined into complex solutions.<br /><br />And Scheme programmers? You may have noticed that although Scheme programs are built out of the five special forms, Scheme programmers do not write everything in the five forms: they use abstractions like continuations, macros, and functions to write expressive and powerful programs.<br /><br />If you re-wrote a complex Scheme program in the five primitives, would it really be easier to understand because one programmer could describe it to another using just five words in their common vocabulary?<br /><br /><hr/><br />This is a follow-up to <a href="http://raganwald.github.com/2007/12/newly-discovered-design-pattern-code.html">Newly Discovered Design Pattern: &ldquo;Code Well.&rdquo;</a><br /><br /><strong>addendum</strong><br /><br />Scheme&#8217;s five special forms: The ones I was thinking of are <code>define</code>, <code>lambda</code>, <code>if</code>, <code>quote</code>, and <code>set!</code>. And I&#8217;m not convinced you need <code>define</code>. This is from memory, and furthermore just because you <em>can</em> build everything from a few primitives doesn&rsquo;t mean that that&rsquo;s how the implementation works. Smalltalk took this aggressive approach to building Smalltalk in Smalltalk, but I am not immersed in Scheme, I do not know what current implementations actually do.<br /><br />If you do a little Googling, you will find that people often refer to constructs like <code>let</code> as special forms, because they are not function calls. However, they are not <em>primitive</em> special forms because you can build <code>let</code> out of <code>lambda</code> and function calls.<br /><br />Given the primitive special forms, you also need a library with functions like <code>equals</code>, <code>car</code>, and <code>cdr</code> defined. Between the primitive forms and the primitive library, you can define <code>eval</code> <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html" title="The significance of the meta-circular interpreter">metacircularly</a> and <code>define-syntax</code> for all of the other special forms. From there, you can build a modern Scheme in Scheme.<br /><br />(There may be some other good choices for building &ldquo;a Scheme.&rdquo; You may want to consider <code>call/cc</code> a primitive special form. If you don&#8217;t, you have to rewrite function calls (probably using CPS), and this means you are no longer running your Scheme programs in your primitive Scheme, but rather in your evaluator.)<br /><br /><strong>And furthermore&hellip;</strong><br /><br />Keith Braithwaite&rsquo;s <a href="http://peripateticaxiom.blogspot.com/2008/01/problem-with-problems-with-patterns.html" title="The problem with Problems with Patterns">critique</a>.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/pouring-water-back-into-flask.html" title="permanent link">10:37 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, December 21, 2007</div>
			

			<div class="Post"><a name="1341343128473928979">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/newly-discovered-design-pattern-code.html" title="permanent link">Newly Discovered Design Pattern: "Code Well."</a></span>
					<div style="clear:both;"></div><blockquote>When I was in college, one of the jobs I had was a TA for an intro programming class. For one of their projects, I was asked to whip up a kind of web browser &#8220;shell&#8221; in Java. The basic idea was to make a browser that would be highly extendable by students, while freeing them from worrying about the overall rendering framework.<br /><br />Now, the first language that I learned was Smalltalk, which has historically been relatively design-pattern-free due to blocks and whatnot, and I had only learned Java as an afterthought while in college, so I coded in a slightly unorthodox way, making use of anonymous inner classes (i.e., shitty lambdas), reflection, and the like. I ended up with an extremely loosely coupled design that was extremely easy to extend; just unorthodox.<br />  <br />When I gave it to the prof, his first reaction, on reading the code, was&#8230;utter bafflement. He and another TA actually went over what I wrote in an attempt to find and catalog the GoF patterns that I&#8217;d used when coding the application. Their conclusion after a fairly thorough review was that my main pattern was, &#8220;Code well.&#8221;<br />  <br />That year, the class didn&#8217;t actually end up using any of the code I wrote, but a year or two after I quit being a TA for the course, they did. I took a look at what became of what I wrote. Needless to say, it now made extraordinarily heavy use of patterns everywhere&#8212;and had a massively larger code footprint as a result&#8212;but, after all, it&#8217;s important to show the young peons how to use patterns. (Euf&#8230;)<br />  <br />So, yes, I have to agree that dogmatic use of design patterns hurts, and that a new language won&#8217;t automatically eliminate that.<br /><br />But I&#8217;d like to believe that a language that doesn&#8217;t take ten lines of code to invoke a method by reflection, or five lines to write what in any decent language would be a one-line lambda, would at least help.</blockquote><div>Gecko on <a href="http://programming.reddit.com/info/63mw9/comments/c02q5wj" title="response to 'Mr. Yegge meets Mr. Brooks'">programming.reddit.com</a></div><br />The follow-up: <a href="http://raganwald.github.com/2007/12/pouring-water-back-into-flask.html">Pouring water back into the flask</a>.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/newly-discovered-design-pattern-code.html" title="permanent link">5:41 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, December 20, 2007</div>
			

			<div class="Post"><a name="7164239232782092678">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html" title="permanent link">Golf is a good program spoiled</a></span>
					<div style="clear:both;"></div>A reader mentioned that &ldquo;It&#8217;s not about lines of code.&rdquo; And he was right: Brevity alone is an unreliable way to judge a program. The problem is&mdash;quite simply&mdash;the existence of <a href="http://en.wikipedia.org/wiki/Perl#Perl_golf" title="Perl - Wikipedia, the free encyclopedia">Golf</a>. In any Turing Equivalent language, it is possible to construct programs that are very small and very difficult to understand.<br /><br />Brevity is not our goal, but it <em>is</em> a side-effect of what happens when we write software well. These are my thoughts about the relationship between program size and readability. It&rsquo;s my take on how you can look at one short program and dismiss it as Golf, and look at another and praise it as being succinct and expressive.<br /><br /><strong> what really matters</strong><br /><br />So what really matters? What is it about well-written software that makes it succinct and elegant? Let&#8217;s look at an absurdly trivial snippet of code and talk about five different ways we could express its intent:<pre><code><br />a = b + c * 2<br />d = e + f * 2<br />g = h + j * 2<br />k = m + n * 2<br />p = q + r * 2</code></pre><br />Hmm. Thirty-five symbols. What about this:<pre><code><br />def addtimestwo(x,y)<br />    x + y * 2<br />end<br /># ...<br />a = addtimestwo(b,c)<br />d = addtimestwo(e,f)<br />g = addtimestwo(e,f)<br />k = addtimestwo(m,n)<br />p = addtimestwo(q,r)</code></pre><br />Twenty-eight symbols. Hey, we can also do this:<pre><code><br />def addtimestwo(x,y)<br />    x + y * 2<br />end<br /># ...<br />a, d, g, k, p = addtimestwo(b,c), addtimestwo(e,f), addtimestwo(e,f), addtimestwo(m,n), addtimestwo(q,r)</code></pre><br />The same twenty-eight symbols. That leads us to:<pre><code><br />a, d, g, k, p =  *[[b,c],[e,f],[h,j],[m,n],[q,r]].map { |x,y| x + y * 2 }</code></pre><br />Twenty-five symbols. Which reminds me:<pre><code><br />a, d, g, k, p =  *[[b,e,h,m,q],[c,f,j,n,r]].zip.map { |x,y| x + y * 2 }</code></pre><br />Twenty-six symbols, but fewer arrays. Comparing them, is the last one less readable than the first? Less &#8220;intuitive&#8221;?<br /><br />Let&#8217;s get that word out of the way immediately. &#8220;Intuitive&#8221; is not some wonderful principle that guides us to creating great software. It means no more and no less than &#8220;familiar.&#8221; <a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html" title="Programming conventions as signals">There&#8217;s value in doing the same things the same ways</a>, but only when it&#8217;s the right thing to do in the first place. Learn your tools.<br /><br /><!--<div class="book"><hr/><strong>An absurd example</strong><br /><br /><em>Take any large program you consider readable, compress it, and express the compressed result as a string using Base64. Now write a wrapper that decompresses the string to a file, compiles that file to an executable, and runs the result (or calls an interpreter on the file). For a non-trivial program, this will be substantially smaller. And entirely incomprehensible. So we have an two programs, each producing the same result, and the one that is smaller is impossible to understand. Note well that this example is independent of language choice: it is possible to make unreadable programs in any language.</em><hr/></div>-->So which of these trivial examples is better? And what does that tell us about program size? Let&#8217;s look at the examples and what they tell us. The first example tells us that there is no relationship between the various expressions, none. The second, where we have &#8216;abstracted out&#8217; the <code>addtimestwo</code> method, tells us that it is no co&iuml;ncidence that the five expressions used the same formula: they are the same thing.<pre><code><br />def addtimestwo(x,y)<br />    x + y * 2<br />end<br />a = addtimestwo(b,c)<br />d = addtimestwo(e,f)<br /># ...</code></pre><br />If that calculation was a piece of business logic, we might want to ensure that if you change one, the others all change as well. In the second example, they are on separate lines, suggesting that although the calculation is shared, the individual assignments are still decoupled from one another. It suggests to me that you might want to remove one, or move it elsewhere.<br /><br />In the third example, we have moved them all onto the same line.<pre><code><br />a, d, g, k, p = addtimestwo(b,c), addtimestwo(e,f), addtimestwo(e,f), addtimestwo(m,n), addtimestwo(q,r)</code></pre><br />In some languages, we might have moved all of the assignments into their own block. By grouping them, we have indicated very strongly that the five assignments belong together. In an imperative language like Ruby, this <a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html" title="Programming conventions as signals">signals</a> that there is something &#8216;atomic&#8217; about this, and that you don&#8217;t want anything else to happen until all five assignments have been mode.<pre><code><br />a, d, g, k, p =  *[[b,c],[e,f],[h,j],[m,n],[q,r]].map { |x,y| x + y * 2 }<br />a, d, g, k, p =  *[[b,e,h,m,q],[c,f,j,n,r]].zip.map { |x,y| x + y * 2 }</code></pre><br />The fourth and fifth examples are special. The fourth example says that the inputs to these calculations is already arranged in a particular structure. The fifth example says that they are arranged in a different structure, but we will use a particular <a href="http://raganwald.github.com/2007/11/really-useful-anamorphisms-in-ruby.html" title="Really useful anamorphisms in Ruby">unfold</a>&mdash;zip&mdash;to get them into the form we want to do the calculating.<br /><br /><strong>detour ahead</strong><br /><br />This is exactly where expressive languages shine, and simultaneously it is exactly where you can go badly wrong in a quest to achieve size for size&#8217;s sake. This is a trivial example, but please extrapolate the principle upwards to lambdas, methods, objects, hierarchies, modules, frameworks, and applications.<br /><br /><div class="book"><hr><em><a id="lnx0" name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X"><img src="http://raganwald.github.com/assets/images/old//seasoned_schemer.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br><a name="evtst|a|026256100X" href="http://www.amazon.com/gp/product/026256100X?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=026256100X">The Seasoned Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=026256100X" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"> is the sequel to the phenomenal book <a id="lnx2" name="evtst|a|0262560992" href="http://www.amazon.com/gp/product/0262560992?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0262560992">The Little Schemer</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0262560992" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1">, a book that teaches recursion and first-class functions. The Seasoned Schemer dives into first-class functions and teaches you how to express relationships by composing and combining functions. It&rsquo;s a powerful abstraction that every programmer should have in their toolbox.</em><hr></div>The fourth and fifth examples are shorter than the first and second, but they are much worse if what they imply&mdash;a relationship between the inputs to the calculations&mdash;is contrived solely to shorten the code.<br /><br />On the other hand, if that relationship actually does exist, then they are far, far superior to the other examples. If there <em>is</em> a relationship there, the most important thing, the clearest thing, is to express the relationship, <em>to make the code we write clearly communicate the semantics of the data it manipulates</em>.<br /><br /><strong>no free lunch</strong><br /><br />Let&#8217;s look at example two again:<pre><code><br />def addtimestwo(x,y)<br />    x + y * 2<br />end<br />a = addtimestwo(b,c)<br />d = addtimestwo(e,f)<br /># ...</code></pre><br />Many people feel that regardless of the expressive power of their language, if it supports procedure calls, they&#8217;re good to go: they can abstract things into procedures, and bundle procedures into libraries, and with good design and decoupling and muttering yaddda yadda yadda while waving their hands just right, the result will be manageable, readable, abstracted code.<br /><br />Ok, I&#8217;m pulling their legs. It isn&#8217;t wrong, it&#8217;s absolutely correct that you can get an enormous win out of abstracting procedures, just like example two. But although that is good, having other ways to organize code is <em>better</em>. Example two adds some overhead: you have to read <code>addtimestwo</code> and control-click the label to jump to the implementation (alert to IDE lovers: I do this kind of thing in Ruby as well, please don&#8217;t assume that the rest of us are scrabbling with Notepad.exe).<br /><br />This abstraction adds overhead. &#8220;Abstracting&#8221; the common operation has made it more difficult to read, not less difficult to read. People for who consider meta-programming some sort of Black Magic often make this exact point: The mechanism for removing duplication adds complexity itself. One view is that the overall effect is only a win if the complexity added is small compared to the duplication removed.<br /><br />Another view, the one I am promoting here, is that it isn&#8217;t about removing symbols, it&#8217;s about communicating something about the underlying relationships. Even if your language is so crufty that example two is longer than example one, it&#8217;s the right thing to do if the calculations are the same for a deep reason, if you are trying to communicate that they will always be the same.<br /><br />That being said, my experience is that when a relationship exists, the code that clearly expresses it usually winds up being shorter than code that does not express it.<br /><br /><strong>relevance in the age of blub</strong><br /><br /><blockquote>Programming languages teach you not to want what they cannot provide.</blockquote><div>&#8212;Paul Graham, <a href="http://lib.store.yahoo.net/lib/paulgraham/acl1.txt">ANSI Common Lisp</a></div><br />I said usually. And here is the pitch for more expressive languages. Languages make expressing certain things easier than others. Each language has its strengths and weaknesses in these areas. Have you noticed how many blog posts have been written explaining <a href="http://osteele.com/archives/2007/12/overloading-semicolon" title="Overloading Semicolon, or, monads from 10,000 Feet">Monads</a>? <br /><br />The problem with languages is that if you are diligent, you will carefully organize your code to express all of the relationships <em>that your language supports</em>. So in Pascal, you factor out all of the common functions and procedures. And when you are done, you have maximally &#8220;compressed&#8221; your code. Not in the sense of creating an unreadable mess, but you have made your code as small and as elegant as you think is possible and prudent.<br /><br />But there are two problems. Pick one:<br /><ul><li>You <em>do</em> know other languages, and you recognize the other relationships that Pascal does not express well. So you Greenspun OO into your code base, and you&#8217;re hacking away at first-class functions. Now you can express these other relationships, but your code base is extremely idiosyncratic, and in many cases the code is longer and more convoluted because you have to do weird backflips to make the language try to pretend to be Java or Factor.</li><br /><li>You <em>don&#8217;t</em> know any other languages, so you think that you have done your best. You have no idea why other programmers are mumbling about Objects, or <a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html" title="Closures and Higher-Order Functions">First-Class Functions</a>, these weird things merely make the code an unreadable mess. You don&#8217;t see the underlying relationships those techniques express because you are a Pascal programmer.</li></ul><br />Either way, Pascal places limits on how well you can express the underlying relationships between things in your programs. The difference between the two situations is the difference between blissfully moving dirt because &#8220;that&#8217;s what we do, we move dirt,&#8221; and swearing under your breath all day as you fight a losing battle against dirt taking over your construction site.<br /><br /><blockquote>An &#8220;X programmer&#8221;, for any value of X, is a weak player. You have to cross-train to be a decent athlete these days. Programmers need to be fluent in multiple languages with fundamentally different &#8220;character&#8221; before they can make truly informed design decisions.</blockquote><div>&mdash;Steve Yegge, <a href="http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html">Code&rsquo;s Worst Enemy</a></div><br />Let&#8217;s look at an <a href="http://www.codinghorror.com/blog/archives/001020.html" title="On The Meaning of 'Coding Horror'">oft-quoted</a> example from a fictional language. We&#8217;ll call the language <a href="http://raganwald.github.com/2006/10/are-we-blub-programmers.html" title="Are we Blub programmers?">Blub</a>:<pre><code><br />float frubbish = 0.0;<br />for (int i = 0; i &lt; foo.length; ++i) {<br />    for (int j = 0; j &lt; bar.length; ++j) {<br />        for (int k = 0; k &lt; bash.length; ++k) {<br />            frubbish += some_function(foo[i], bar[k], bash[j]); # updated<br />        }<br />    }<br />}</code></pre>This is so wrong in so many ways, but let&#8217;s start with the obvious bug. If are a Junior Blub Programmer, you believe that this algorithm expresses the underlying relationship properly, so you just fix the bug. If you are a Senior Blub Programmer, you don&#8217;t just fix the bug, but you add meaningful variable names so that <a href="http://www.joelonsoftware.com/articles/Wrong.html" title="Making Wrong Code Look Wrong - Joel on Software">wrong code looks wrong</a>:<pre><code><br />float frubbish = 0.0;<br />for (int index_foo = 0; index_foo &lt; foo.length; ++index_foo) {<br />    for (int index_bar = 0; index_bar &lt; bar.length; ++index_bar) {<br />        for (int index_bash = 0; index_bash &lt; bash.length; ++index_bash) {<br />            frubbish += some_function(foo[index_foo], bar[index_bar], bash[index_bash]);<br />        }<br />    }<br />}</code></pre>Ah, but if you are a Blub <em>Architect</em>, you realize that asking programmers to use meaningful variable names to keep out of trouble won&#8217;t work. Why, if that&#8217;s all it took, we could use dynamically typed languages like Javascript! No, we must put the compiler to work so that it is impossible to make this mistake. In fact, that&#8217;s exactly how Ada works: There is a special type for &#8220;the index of a foo,&#8221; and it is different from the type for &#8220;the index of a bar,&#8221; so the buggy code wouldn&#8217;t even have compiled. You can do this with C++ as well, and let&#8217;s pretend you can do it with Blub:<pre><code><br />float frubbish = 0.0;<br />for (IndexFoo index_foo = new IndexFoo(0); index_foo &lt; foo.length; ++index_foo) {<br />    for (IndexBar index_bar = new IndexBar(0); index_bar &lt; bar.length; ++index_bar) {<br />        for (IndexBash index_bash = new IndexBash(0); index_bash &lt; bash.length; ++index_bash) {<br />            frubbish += some_function(foo[index_foo], bar[index_bar], bash[index_bash]);<br />        }<br />    }<br />}</code></pre>The Junior, the Senior, and the Architect are all thinking within the limitations of Blub. They still want to write the same program, they don&#8217;t see that the index variable, the test for the end of the loop, the nesting of loops, and incrementing an index have nothing to do with the basic relationship you are trying to express.<br /><br />Instead of asking themselves <em>why</em> they have index variables, (or better still, why they have nested loops), the Blub programmers are asking themselves how to minimize the problems index variables create.<br /><br /><blockquote>People tend to view code bases much the way construction workers view dirt: they want great big machines that can move the dirt this way and that. There&#8217;s conservation of dirt at work: you can&#8217;t compress dirt, not much, so their solution set consists of various ways of shoveling the dirt around&#8230;</blockquote><div>&mdash;Steve Yegge, <a href="http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html">Code&rsquo;s Worst Enemy</a></div><br />Index variables are dirt, and being a better Blub programmer is an exercise in learning more sophisticated ways to handle dirt. The Java Programmer has been liberated from this kind of thinking. She writes:<pre><code><br />float frubbish = 0.0;<br />for (float each_foo: foo) {<br />    for (float each_bar: bar) {<br />        for (float each_bash: bash) {<br />            frubbish += some_function(each_foo, each_bar, each_bash);<br />        }<br />    }<br />}</code></pre><div class="book"><hr><em><a id="lnx0" name="evtst|a|0596510047" href="http://www.amazon.com/gp/product/0596510047?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0596510047"><img src="http://raganwald.github.com/assets/images/old//beautiful_code.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0596510047" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br>In <a name="evtst|a|0596510047" href="http://www.amazon.com/gp/product/0596510047?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0596510047">Beautiful Code</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0596510047" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1">, great programmers reveal how they found unusual, carefully designed, and beautiful solutions to high-profile projects like regular expression engines, distributed computation, software transactional memory, hygienic macro processing, and twenty-one others.<br /><br />The authors of Beautiful Code share their thinking and problem solving process with us. And that&rsquo;s why this book transcends so many other books about programming: thinking and problem solving approaches are universal. This isn&rsquo;t a book about programs, it&rsquo;s a book about programming, and with every chapter you read you will become a better programmer.<br /></em><hr></div>She is not concerned with ways to prevent mistakes with index variables, because Java gives her a tool to make them go away. While the Blub programmers are arguing about how to manage dirt, she is writing code that expresses the relationship she wishes to communicate.<br /><br />Her code is shorter, yes. And much better. And the reason it is much better, the desirable property of her code, is that it communicates the actual thing going on and does not communicate a bunch of other things that are irrelevant.<br /><br />Those extra moving parts, the <a href="http://raganwald.github.com/2006/12/economizing-can-be-penny-wise-and.html" title="Economizing can be penny-wise and pound foolish">yellow code</a>, the accidental complexity makes the code harder to read. It adds opportunities for errors. It makes it harder to maintain. And all because it contains dirt, it contains things that do not express some fundamental relationship in the data.<br /><br />Shorter code is more readable when it is shorter by dint of expressing the underlying relationship, without irrelevant details.<br /><br />Alas, while everyone agrees with this statement, the tyranny of programming in Blub is that the Blub programmer does not know that his code contain irrelevant details: he thinks his code does express all of the necessary ideas in his algorithm, he considers shorter code &ldquo;cryptic.&rdquo;<br /><br /><strong>thank god, his typewriter ribbon is running dry</strong><br /><br />Now we can see that although each language provides abstraction mechanisms, and lets you build new abstractions with the mechanism, new <em>kinds</em> of abstractions give us new ways to express relationships. These things can be abused, of course, but nothing can save you from this: If you don&rsquo;t let your Architect play with Domain-Specific Languages, what is to stop them from <abbr title="Also known as, 'The cure is worse than the disease'">configuring everything in your application with XML</abbr>?<br /><br />The goal is readable code that expresses the underlying relationships. When we are programming in our personal Blub, the only relationships we see are the ones our language affords. Thus, we are always tempted to think that are programs already are as readable as the underlying problem domain allows, and that efforts to make them shorter are circus tricks that make the code less readable.<br /><br />And the only way to break out of Blub is to cross-train, to really <a href="http://raganwald.github.com/2007/10/challenge-of-teaching-yourself.html" title="The challenge of teaching yourself a programming language">learn new languages</a>. Otherwise, how will you know if your code could be shorter in a good way?<br /><br />Shorter code <em>is</em> better if it expresses underlying relationships, if it is shorter because it does not contain irrelevant cruft, if it does not contain workarounds and hacks to deal with limitations in the programming language. Of course, shorter code is not <em>always</em> better. If it is &#8220;shorter by co&iuml;ncidence,&#8221; by exploiting language tricks that do not reflect underlying relationships in your programs, that is bad.<br /><br />Golf is a good program spoiled.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html" title="permanent link">12:31 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, December 19, 2007</div>
			

			<div class="Post"><a name="8832340561102542405">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/growing-sense-of-doom-washed-over-me-as.html" title="permanent link">A growing sense of doom washed over me as I read Steve's latest post</a></span>
					<div style="clear:both;"></div><em>As a few people have noticed, this went out over RSS but was not on my site. The reason is that I &ldquo;pulled&rdquo; it. I started out thinking I would include some choice quotes from Steve&rsquo;s essay and leave it at that, but&hellip; At some point I got enthusiastic and decided I wanted to say something about the culture of moving dirt (I think I have run out of things to say about Java the language, thank goodness). However, reality in the form of interesting work at work popped up, so I decided to put the essay off.<br /><br />Bad luck, the post was already out on RSS. So here it is. I would like to rewrite it fully, just not right now. Sorry for letting it out onto RSS in such a half-baked form. I realize your time is valuable, and I think you deserve better from me.</em><br /><br /><strong>Update</strong>: <a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a>.<br /><hr/><br /><blockquote>I happen to hold a hard-won minority opinion about code bases. In particular I believe, quite staunchly I might add, that the worst thing that can happen to a code base is size&#8230;</blockquote><br /><blockquote>People in the industry are very excited about various ideas that nominally help you deal with large code bases, such as IDEs that can manipulate code as &#8220;algebraic structures&#8221;, and search indexes, and so on. These people tend to view code bases much the way construction workers view dirt: they want great big machines that can move the dirt this way and that. There&#8217;s conservation of dirt at work: you can&#8217;t compress dirt, not much, so their solution set consists of various ways of shovelling the dirt around&#8230;</blockquote><br /><blockquote>It&#8217;s just a mountain of dirt, and you just need big tools to move it around. The tools are exciting but the dirt is not&#8230;</blockquote><br /><blockquote>The problem with Refactoring as applied to languages like Java, and this is really quite central to my thesis today, is that Refactoring makes the code base larger. I&#8217;d estimate that fewer than 5% of the standard refactorings supported by IDEs today make the code smaller. Refactoring is like cleaning your closet without being allowed to throw anything away. <em>If you get a bigger closet, and put everything into nice labelled boxes, then your closet will unquestionably be more organized. But programmers tend to overlook the fact that spring cleaning works best when you&#8217;re willing to throw away stuff you don&#8217;t need</em>&#8230;</blockquote><br /><blockquote>Design Patterns was a mid-1990s book that provided twenty-three fancy new boxes for organizing your closet, plus an extensibility mechanism for defining new types of boxes. It was really great for those of us who were trying to organize jam-packed closets with almost no boxes, bags, shelves or drawers. All we had to do was remodel our houses to make the closets four times bigger, and suddenly we could make them as clean as a Nordstrom merchandise rack.<br /><br />A design pattern isn&#8217;t a feature. A Factory isn&#8217;t a feature, nor is a Delegate nor a Proxy nor a Bridge. They &#8220;enable&#8221; features in a very loose sense, by providing nice boxes to hold the features in. But boxes and bags and shelves take space. And design patterns â€“ at least most of the patterns in the &#8220;Gang of Four&#8221; book â€“ make code bases get bigger. <em>Tragically, the only GoF pattern that can help code get smaller (Interpreter) is utterly ignored by programmers who otherwise have the names of Design Patterns tattooed on their various body parts</em>&#8230;</blockquote><br /><blockquote>If you begin with the assumption that you need to shrink your code base, you will eventually be forced to conclude that you cannot continue to use Java. Conversely, if you begin with the assumption that you must use Java, then you will eventually be forced to conclude that you will have millions of lines of code&#8230;</blockquote><br /><blockquote>You should take anything a &#8220;Java programmer&#8221; tells you with a hefty grain of salt, because an &#8220;X programmer&#8221;, for any value of X, is a weak player. You have to cross-train to be a decent athlete these days. <em>Programmers need to be fluent in multiple languages with fundamentally different &#8220;character&#8221; before they can make truly informed design decisions</em>&#8230;</blockquote><br /><blockquote>Java is like a variant of the game of Tetris in which none of the pieces can fill gaps created by the other pieces, so all you can do is pile them up endlessly.<br /><br />Imagine that you have a tool that lets you manage huge Tetris screens that are hundreds of stories high. In this scenario, stacking the pieces isn&#8217;t a problem, so there&#8217;s no need to be able to eliminate pieces. This is the cultural problem: they don&#8217;t realize they&#8217;re not actually playing the right game anymore&#8230;</blockquote><br /><blockquote>Java-style IDEs intrinsically create a circular problem. The circularity stems from the nature of programming languages: the &#8220;game piece&#8221; shapes are determined by the language&#8217;s static type system. Java&#8217;s game pieces don&#8217;t permit code elimination because Java&#8217;s static type system doesn&#8217;t have any compression facilities â€“ no macros, no lambdas, no declarative data structures, no templates, nothing that would permit the removal of the copy-and-paste duplication patterns that Java programmers think of as &#8220;inevitable boilerplate&#8221;, but which are in fact easily factored out in dynamic languages.<br /><br />Dynamic features make it more difficult for IDEs to work their static code-base-management magic. IDEs don&#8217;t work as well with dynamic code features, so IDEs are responsible for encouraging the use of languages that require&#8230; IDEs. Ouch&#8230;</blockquote><div>&mdash;All quotes from <a href="http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html">Code's Worst Enemy</a> by Steve Yegge</div><br />I have read many essays taking the minority position and explaining what is wrong with the &ldquo;Java Programmer&rdquo; mindset (as opposed to the &ldquo;Programmer who happens to use Java mindset&rdquo;), but Steve&rsquo;s essay laid the cultural problems bare for me. He explains the technical issues well, but where this essay really shines is explaining the cultural issues and how they work with the technical issues to create a vicious cycle.<br /><br />Of course I recommend reading the original. But may I add, please do not get sucked into arguing whether Design Patterns are good, or whether IDE refactorings really work, or any of the other <em>technical</em> points that are so much fun to rehash for the millionth time.<br /><br />Instead, consider the cultural forces at work. Cultural problems cannot be solved with technology. If you are an advocate for change, ask yourself what sort of cultural change is needed, not what sort of technical problems need to be solved.<br /><br />And oh yes&hellip; What do <em>you</em> think of his central thesis?<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/growing-sense-of-doom-washed-over-me-as.html" title="permanent link">11:31 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Tuesday, December 18, 2007</div>
			

			<div class="Post"><a name="1102778159953706937">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/yard-sale-at-raganwalds-house.html" title="permanent link">Yard Sale at Raganwald's House</a></span>
					<div style="clear:both;"></div>I&rsquo;ve taken a weed whacker to the article links on the weblog&rsquo;s sidebar (Heh, only an author would think that removing seven links is anything but a minor adjustment! But still, I&rsquo;m fond of them all, it is difficult to let them go).<br /><br />Here are the links I have removed:<br /><ol><li><a href="http://raganwald.github.com/2007/09/ockhams-razor-as-it-applies-to-big.html">Ockham&rsquo;s razor as it applies to the big rewrite</a></li><br /><li><a href="http://raganwald.github.com/2007/05/icebreakers.html">Icebreakers</a></li><br /><li><a href="http://raganwald.github.com/2006/07/hiring-juggler_02.html">Hiring a Juggler</a> </li><br /><li><a href="http://raganwald.github.com/2005/03/are-you-thinking-of-working-for-start.html">Are you thinking of working for a start up?</a> </li><br /><li><a href="http://raganwald.github.com/2007/10/three-blog-posts-id-love-to-read-and.html">Three blog posts I'd love to read (and one that I wouldn't)</a> </li><br /><li><a href="http://raganwald.github.com/2007/04/haskell-not-just-for-language-weenies.html">What Haskell teaches us about writing Enterprise-scale software</a> <a href="http://raganwald.github.com/2007/04/haskell-not-just-for-language-weenies.html" title="Don't have a COW, man? What Haskell teaches us about writing Enterprise-scale software">I</a>, <a href="http://raganwald.github.com/2007/05/hard-core-concurrency-considerations.html" title=" Hard-Core Concurrency Considerations">II</a> </li><br /><li><a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> </li></ol><br />Sniff. I&rsquo;ll miss them!<br /><br />While I&rsquo;m wallowing in grief, I might as well mention a few of my favourites that haven&rsquo;t quite made it into the starting rotation. You know, sixth man and all that:<br /><ol><li><a href="http://raganwald.github.com/2007/10/zen-in-art-of-rewriting.html">Zen in the Art of Rewriting</a></li><br /><li><a href="http://raganwald.github.com/2007/04/rails-style-creators-in-java-or-how-i.html">Rails-style creators in Java, or, how I learned to stop worrying and love anonymous inner classes</a></li><br /><li><a href="http://raganwald.github.com/2007/04/what-does-barbara-liskov-have-to-say.html">What does Barbara Liskov have to say about Equality in Java?</a></li><br /><li><a href="http://raganwald.github.com/2006/10/why-are-local-variables-bad.html">Why are local variables bad?</a></li></ol><br />Well, it&rsquo;s time to stick a price tag on them and carry them out to the lawn. Good bye, dear articles. Best of luck wherever you end up&hellip;<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/yard-sale-at-raganwalds-house.html" title="permanent link">9:00 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, December 16, 2007</div>
			

			<div class="Post"><a name="8460874430472357553">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/linus-torvalds-on-big-design-up-front.html" title="permanent link">Trial-and-error with a feedback cycle</a></span>
					<div style="clear:both;"></div><blockquote>Don&rsquo;t EVER make the mistake that you can design something better than what you get from ruthless massively parallel trial-and-error with a feedback cycle.<br /><br />That's giving your intelligence <i>much</i> too much credit.</blockquote><div>&mdash;<a href="http://groups.google.com/group/fa.linux.kernel/msg/52f04d4ab1121c9b">Linus Torvalds</a></div><br /><br /><strong>trial and error</strong><br /><br />A common mistake when trying to be &ldquo;Agile&rdquo; (or trying to appear to be Agile without actually being Agile) is to shorten milestones while still maintaining the idea that we have a plan for every milestone done up at the beginning of the project and we consider changing the plan to be a management failure.<br /><br />The whole point of trial and error is to make our plan, but to accept the inevitability that our plan will not survive contact with reality. I was working on one project, and the first two-week cycle went badly sideways. The project manager complained that she <i>hates</i> missing milestones early in a project, it foreshadows all sorts of problems. She wanted to impose overtime to hit the date.<br /><br />I urged restraint. If we were wrong about our velocity, or wrong about some of our technical predictions, or wrong about some of the requirements, it would be far better to adjust our expectations. The two-week cycles were a bonus because they were providing the feedback we needed to adjust our plans.<br /><br />If you ignore the evidence, if you try to twist the appearance of reality to suit your plan rather than twist your plan to suit reality, the feedback is wasted.<br /><br /><strong>feedback</strong><br /><br />Feedback is so critical, that even if you do everything else right, and even if you think you are gathering and responding to feedback, you can still fail. A recent flurry of blog posts discussed <a href="http://gojko.net/2007/12/04/waterfall-trap/" title="The waterfall trap for â€œagileâ€ projects">The Waterfall Trap</a>. This is when you build software incrementally instead of iteratively.<br /><br />Increments are components of the finished software that do not provide value in and of themselves, like a database and its associated <a href="http://blogs.tedneward.com/2006/06/26/The+Vietnam+Of+Computer+Science.aspx" title="The Vietnam of Computer Science">ORM</a> doo-hicky. When you build an increment, what feedback do you have? Feedback about how well you are executing against <span style="font-style:italic;">your plan</span>.<br /><br />This is like deciding to march through the jungle and measuring how many steps you take per day. Are you going in the right direction? Who knows, but you know you how fast you are going, and that is worth something, isn&rsquo;t it?<br /><br />I can tell you exactly what it is worth. At some meeting later on, when the project has been judged an expensive failure, you can prove it was a <em>well-managed failure</em> under your watch. Congratulations.<br /><br />For feedback to really work, you must have feedback about how well the finished software delivers value to its users. The only way to do that is to deliver it to those users and get <em>their</em> feedback. Thus, the other approach: to build the software iteratively. This means to build things that are valuable in and of themselves, so users can judge how well they work.<br /><br /><strong>productization</strong><br /><br />My Golden Hammer for building software iteratively is to divide it into <a href="http://raganwald.github.com/2007/08/how-many-products-make-up-project.html">separate products</a>. We sit down and look at the pile of functionality on the plan and ask, &ldquo;Which of these pieces could be useful things in and of themselves?&rdquo;<br /><br />On one project, there was a complex bit of <a href="http://raganwald.github.com/2007/07/javascript-on-jvm-in-fifteen-minutes.html">loan eligibility reasoning</a> that needed to be built into a database application. We decided that although the finished application would have the reasoning built into certain input screens, the reasoning could be a separate product. We imagined this thing sitting in its own screen alongside what their existing process.<br /><br />There would be some double entry involved, but we knew that if we built this as a stand-alone product, it could be used in production and it could provide value. So we did. And sure enough, we got a lot of feedback from the users. We didn't end up deploying it in production, they wanted to wait for the rest of the pieces to be built, but they could play with it, they could see how it worked, they could give us real feedback.<br /><br />Did I mention they decided against deploying it in production until the rest of the project was ready? That was the most critical piece of feedback yet. It told us it wasn&rsquo;t as important as we thought, and we were able to reprioritize around other things.<br /><br />That kind of feedback is only possible when you get feedback about the value you are providing. And that is exactly the feedback Linus is talking about: the ruthless feedback of users who don&rsquo;t care about your plans or your years of experience or your blog or whether you work for a billion-dollar company or whether you use Java or JRuby, or whether your servers are MSFT or Linux.<br /><br />The feedback you get from people who just want to get stuff done.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/linus-torvalds-on-big-design-up-front.html" title="permanent link">11:45 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Saturday, December 15, 2007</div>
			

			<div class="Post"><a name="9059803522407815872">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/grinch-who-stole-ruby-jobs.html" title="permanent link">The Grinch Who Stole the Ruby Jobs</a></span>
					<div style="clear:both;"></div>A reader was kind enough to point out that making statements about jobs being advertised could be misconstrued as a statement about the policies of the companies doing the hiring.<br /><br />I do not speak for any hiring company, and I&rsquo;m sure that hiring companies do not particularly want me articulating their policies for them.<br /><br />Therefore, my policy hereforward is that when I wish to describe a job, I will provide links to open positions or name companies hiring. If I quote something, it is partially or fully information provided by the company and it will be indicated as such in quote marks.<br /><br />I know, what a bother. Sheesh. But there you have it, that seems to be the way the world works. Roll with it and let&rsquo;s move on.<br /><br /><hr/><br /><blockquote><a href="http://www.mdlogix.com/">mdlogix</a>, a rapidly growing medical research software company is seeking Ruby on Rails developers for our downtown Toronto office.<br /><br />We're looking for passionate developers who love Rails and want to make the world a better place by supporting clinical research! <br /><br />For more information, visit <a href="http://www.mdlogix.com/aboutUs/jobSoftwareEngineerToronto.html">http://www.mdlogix.com/aboutUs/jobSoftwareEngineerToronto.html</a> or speak to us at the next <a href="http://unspace.ca/innovation/pubnite/">Rails pub night</a>!</blockquote><br /><br /><a href="http://www.hewitt.com/">Hewitt Associates</a> is looking for a &ldquo;P/A with Ruby on Rails experience,&rdquo; possibly in Toronto (No link: they use an HR application for job listings that supports nice searches but mightily resists bookmarking).<br /><br /><blockquote>GigPark is a Toronto-based web startup that's growing fast             <br />Built with Ruby on Rails and hosted on EC2<br />We develop iteratively and release weekly<br />We care about quality - our code is well-designed and tested<br />We work hard, but smart. We believe less code is better and simple UI design is key             We're not religious about technology. We believe in using the right tool for the job<br /><br /><a href="http://www.gigpark.com/page/jobs">http://www.gigpark.com/page/jobs</a></blockquote><br /><br /><a href="http://www.mcommons.com/about/jobs">Mobile Commons is looking for &ldquo;junior and senior hackers&rdquo;</a>.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/archives/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/grinch-who-stole-ruby-jobs.html" title="permanent link">2:41 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Thursday, December 13, 2007</div>
			

			<div class="Post"><a name="6067492786283280889">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/its-time-to-stop-blaming-management.html" title="permanent link">IT's time to stop blaming management</a></span>
					<div style="clear:both;"></div><blockquote>Enterprise systems do produce real, significant cost-savings by imposing standards and metrics on what was once chaos. But the result is inevitably software that&#8217;s inflexible and doesn&#8217;t grow well with the business. Enterprise software never ages well, it never evolves fast enough and it is always vulnerable to disruption&thinsp;&mdash;&thinsp;as you might expect of any system that adopts such a command-and-control, monolithic position with regard to its users.</blockquote><div>&#8212;the aptly named blog <a href="http://blogs.concedere.net:8080/blog/discipline/web/?permalink=Thinking-Big-at-the-Google-Scale.html" title="Thinking Big at the Google Scale">discipline and punish</a></div><br />I&#8217;ll repeat one bit for emphasis: <em>&#8230;The result is inevitably software that&#8217;s inflexible and doesn&#8217;t grow well with the business. Enterprise software never ages well, it never evolves fast enough and it is always vulnerable to disruption&thinsp;&mdash;&thinsp;as you might expect of any system that adopts such a command-and-control, monolithic position with regard to its users.</em><br /><br />Now let me ask: Should we expect this to apply to finished Enterprise Software Applications and not to the code produced inside Enterprises? I think it applies decisively to Enterprise Code Bases, and this isn&#8217;t something we can blame on Pointy-Haired Bosses.<br /><br />When an &#8220;Enterprise Architect&#8221; drives a Platform, Framework, Tool, and Language &ldquo;Strategy&rdquo; that is all about Command and Control over the users of same platforms, frameworks, tools, and languages, you get <em>exactly the same result</em>. And who uses these things? Developers. The moment your driving motivation is controlling developers and restricting what they do, you go down the exact same road and end up in the exact same place as when your driving motivation is command and control over users.<br /><br /><blockquote>While some consider the slow rate of change of enterprise software to be a feature and not a bug this sort of logic isn&#8217;t very persuasive anymore and won&#8217;t fly far in the age of the web. The the web has clearly demonstrated that it&#8217;s possible to build a huge, stable, decentralized platform that still allow for all kinds of innovation without imposing undue restrictions on everybody and everything.<br /><br />(Ironically the key ingredient may turn out to be trust, of all things, which is something any enterprises&#8212;being notoriously paranoid&#8212;are forever lacking.)</blockquote><div><em>ibid.</em></div><br />Software built with tools and policies that fight developers at every step is frighteningly difficult to change, it resists evolution tooth and nail. The argument that it has a lower Total Cost of Ownership in the long run is not just wrong, it turns out to be badly wrong: software developed by people in straight jackets is <em>more expensive</em> to maintain, not less expensive.<sup><font size="-2">1</font></sup><br /><br /><blockquote>Centralization is a bug&hellip; Anything in the system that requires central authority, that&rsquo;s something that holds you back.</blockquote><div>&mdash;Tim Bray, <a href="http://www.tbray.org/ongoing/When/200x/2007/12/12/XBRL-Web">Message From the Web</a></div><br />I am not saying that Anarchy is a viable alternative to Bondage and Discipline. Lots of businesses fail from having too little structure, and software is no different than business in that respect. However, we see plenty of businesses that thrive by pushing decisions downwards, flattening their management structure, by motivating people to do the right thing, by making a commitment to quality staffing, and&#8212;yes, it&#8217;s true&#8212;by choosing to right-size their teams and resist the temptation to grow for growth&#8217;s sake.<br /><br />There is no golden hammer, no silver bullet. It is hard for businesses to thrive and succeed in an environment of change, and it is hard for IT departments as well. But we have to wake up and smell the coffee. We can only blame &#8220;management&#8221; for so much, and then we have to turn our attention to our own practises, to the mistakes <em>we</em> make that mirror the mistakes <em>they</em> make.<br /><br /><hr/><br /><ol><li>Oh yeah? Where&rsquo;s your study to prove it? Good question. I pulled that statement right out of my <em>ass</em>ets, to tell you the truth. Pure opinion based on the Appeal to Authority (20+ years of experience) and Confirmation Bias (successful projects) fallacies. I was going to pull that line, but I find it outrageous that tool vendors and their sycophants promote TCO as a benefit of their approaches without the <em>slightest</em> credible evidence backing it up.<br /><br />Honestly, can <em>anyone</em> produce a study that shows business software written in Popular Language X has a lower TCO than business software written in Lisp? Or Python? Or ML? Or Ruby? Anyone? Anyone? The only things I can find when I look are obvious Blowhard Job studies by consulting groups funded by vendors.<br /><br /><em>Does anyone really know</em>?<br /><br />I have decided that I no longer accept such claims at face value. Not even my own.</li></ol><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/its-time-to-stop-blaming-management.html" title="permanent link">2:15 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			

			<div class="Post"><a name="8424806580539706126">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/i-can-change-any-time-i-want-to-i-just.html" title="permanent link">I can change any time I want to, I just don't want to.</a></span>
					<div style="clear:both;"></div>Does that sound like anything you&rsquo;ve heard before? Perhaps from a smoker? Or someone who does not exercise?<br /><br />Or maybe someone who says they <em>could</em> learn new things, but they are too busy right now keeping on top of what  they already know? Or the converse? Someone who is too busy playing with new things to buckle down and work hard with what they already know?<br /><br />Change is brutally hard. Nobody finds it easy.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/i-can-change-any-time-i-want-to-i-just.html" title="permanent link">9:36 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, December 12, 2007</div>
			

			<div class="Post"><a name="3199936548635835116">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/have-nothing-in-your-house-that-you-do.html" title="permanent link">Have nothing in your house that you do not know to be useful, or believe to be beautiful</a></span>
					<div style="clear:both;"></div>The title is a quote by William Morris, a man with a deep interest in design and its relationship to our place in society. I think it applies to ideas as well as artefacts, and I must warn you that the following ideas fall under &#8220;beautiful&#8221; :-)<br /><br /><strong>The Halting Problem</strong><br /><br /><blockquote>The halting problem is a decision problem about properties of computer programs on a fixed Turing-complete model of computation. The question is, given a program and an input to the program, whether the program will eventually halt when run with that input. In this abstract framework, there are no resource limitations of memory or time on the program&#8217;s execution; it can take arbitrarily long, and use arbitrarily much storage space, before halting. <em>The question is simply whether the given program will ever halt on a particular input</em>.<br />  <br />  The reason the halting problem is famous is because it is undecidable, which means there is no computable function that correctly determines which programs halt and which ones do not.</blockquote><div>&#8212;<a href="http://en.wikipedia.org/wiki/Halting_Problem" title="Halting problem - Wikipedia, the free encyclopedia">Wikipedia</a></div><br />(There seems to be some confusion about what this says. It says that we cannot construct <em>one</em> machine or function or program that can examine any combination of machine or program and input and then correctly decide whether the program halts or does not halt.)<br /><br /><strong>1 + 1 = Cool</strong><br /><br /><div class="book"><hr/><em><a href="http://www.amazon.com/gp/product/0812921178?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0812921178"><img border="0" src="http://raganwald.github.com/assets/images/old//lady_or_tiger.jpg"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0812921178" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br /><br /><a href="http://www.amazon.com/gp/product/0812921178?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0812921178">Lady or the Tiger? And Other Logic Puzzles Including a Mathematical Novel That Features G&ouml;del&rsquo;s Great Discovery</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0812921178" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />: &#8220;Another scintillating collection of brilliant problems and paradoxes by the most entertaining logician and set theorist who ever lived. As in all of Professor Smullyan&#8217;s fantastic puzzle books, you end up exploring that strange subterranean region below mathematics, where G&ouml;delian corridors lead in all directions to beautiful theorems about truth and provability.&#8221;&#8212; Martin Gardner</em><hr/></div>We absolutely <em>know</em> that the Halting Problem is true (meaning there is no function that correctly answers whether every program halts or does not halt). However, the math seems a bit gnarly if you were sleeping through your computability courses. And furthermore, just because we know that there must exist programs for which we do not know whether they will halt for at least one input, it&#8217;s always a lot more convincing to actually look at such a program.<br /><br />The Wikipedia article provides a couple of examples based on unsolved problems in mathematics, the search of an odd <a href="http://en.wikipedia.org/wiki/Perfect_number" title="Perfect number - Wikipedia, the free encyclopedia">perfect number</a> and the search for the largest pair of <a href="http://en.wikipedia.org/wiki/Twin_prime_conjecture" title="Twin prime conjecture - Wikipedia, the free encyclopedia">twin primes</a>. The idea is this: if you can write a program that uses brute force to search for a counter-example to an unsolved problem in mathematics, you have one of three things:<br /><br /><ol><li>You run your program, it finds a counter-example, and you win a Nobel Prize in Mathematics (<a href="http://www.nobelprizes.com/nobel/why_no_math.html">not really!</a>) for disproving the unsolved problem, or:</li><br /><li>You run your program, it goes on running forever, and you can&#8217;t prove that it will ever stop. But it might. If you could prove it would stop than you can also disprove the unsolved problem, so again you win a Nobel Prize in Mathematics.</li><br /><li>You don&#8217;t need to run your program, you know darn well it will never stop, and you can prove it will never stop. Now you have proved the unsolved problem, so again you win a Nobel Prize in Mathematics.</li></ol><br />Of course, alternative four is to accept the idea that there are very simple programs that might run forever but we have no way of knowing if they ever stop.<br /><br />If you go through any of the proofs of the Halting Problem, you already know this. But sometimes, an example is worth a thousand words.<br /><br /><strong>Goldbach&#8217;s Conjecture</strong><br /><br /><blockquote>Goldbach&#8217;s conjecture is one of the oldest unsolved problems in number theory and in all of mathematics. It states: <em>Every even integer greater than 2 can be written as the sum of two primes</em>. In other words, the Goldbach conjecture states that every even number greater than or equal to four is a Goldbach number, a number that can be expressed as the sum of two primes.</blockquote><div>&#8212;<a href="http://en.wikipedia.org/wiki/Goldbach's_conjecture" title="Goldbach's conjecture - Wikipedia, the free encyclopedia">Wikipedia</a></div><br /><br />To review, by <em>unsolved problem</em>, we mean that we haven&#8217;t proved it is true and we also haven&#8217;t proved it is false. So here&#8217;s what we do: Let&#8217;s write a program that checks every even integer from 4 up. If it is the sum of two primes, we try the next higher even number. If it is <strong>not</strong> the sum of two primes, we stop and output the number.<br /><pre><code><br />require 'mathn'<br /><br />@prime_generator = Prime.new<br />@primes = [@prime_generator.succ] # start with [2]<br /><br /># given a number, answer a list with at least all <br /># of the primes &lt;= that number. may include<br /># larger primes.<br />#<br /># primes_at_least_up_to(12) -&gt; [2,3,5,7,11,13] <br /># and possibly more primes<br /># <br />def primes_at_least_up_to(n)<br />  while @primes[-1] &lt; n do <br />    @primes &lt;&lt; @prime_generator.succ<br />  end<br />  @primes<br />end<br /><br />def sum_of_two_primes?(n)<br />  !!(primes_at_least_up_to(n).detect { |p1| <br />      primes_at_least_up_to(n).include?(n-p1) <br />    })<br />end<br /><br />n = 4<br /><br />while sum_of_two_primes?(n)<br />  n +=2<br />end<br /><br />puts n</code></pre><br />Does this program halt? If you can answer this question, you solve a huge problem in Number Theory. Now again, this does <em>not</em> prove the Halting Problem. For one thing, we might solve the Goldbach Conjecture by proving or disproving it, and then we could tell you whether this program halts.<br /><br />Another possibility is that we will prove that the Goldbach Conjecture is undecidable. In that case, we will have a proof that we cannot prove whether this program halts. This has been done with other conjectures. For example, we have proven that we can neither prove nor disprove Cantor&rsquo;s Continuum Hypothesis: it appears that within Number Theory, there is no way to know whether there exist infinities that are both larger than <a href="http://en.wikipedia.org/wiki/Aleph_number">&#1488;-null</a> and smaller than &#1488;-one.<br /><br />This program <em>does</em> demonstrate that at a deep level, programs are math. You can draw an equivalence between certain programs and certain statements in mathematics. We can say that certain properties of Program P (like whether it halts) are equivalent to certain properties of Mathematical Statement S (like whether every even number is the sum of two primes).<br /><br />That connection leads us to Incompleteness. If we know that there must be mathematical statements that are undecidable (like statements that are true but cannot be proved), we know that there are undecidable properties of computer programs. And if we know that there are undecidable properties of computer programs (like whether they halt), we know that there are undecidable statements in mathematics.<br /><br />I find that deeply, deeply interesting.<br /><br /><hr><br />This was provoked by an example from the <a href="http://www.lambdassociates.org/webbook/chap3.htm">Qi language</a> manual. It came at a good time: after writing about various aspects of our industry and its limitations, I needed to be reminded how how much I enjoy thinking about programs.<br /><br />Which brings me back around to the title. Computer Science is a big field. Programming is a big field. Working for a living developing software is a big field. I believe you have to pick and choose, you can&rsquo;t learn everything, you can&rsquo;t try to pick up every new thing that comes along.<br /><br />But I believe that if you follow Morris&rsquo; dictum, you will be effective and also deeply engaged. Do not settle for mediocre ideas. Accept only those things that are useful, beautiful, or both. Do not settle for just beautiful or just useful. It is surprising how often useful things help you build beauty, and likewise how often beautiful things turn out to be useful in a different context.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/have-nothing-in-your-house-that-you-do.html" title="permanent link">2:43 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, December 10, 2007</div>
			

			<div class="Post"><a name="5727070802408468811">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/utility-belt.html" title="permanent link">Utility Belt</a></span>
					<div style="clear:both;"></div><a href="http://utilitybelt.rubyforge.org/" title="Utility Belt: Usage">Utility Belt</a> is a grab-bag of tricks, tools, techniques, trifles, and toys for IRB, including convenience methods, language patches, and useful extensions. It also includes a couple command-line widgets. Its primary inspirations were an awesome gem called <a href="http://www.gemtacular.com/gems/wirble">Wirble</a> and a blog post by Amy Hoy called &#8220;<a href="http://slash7.com/articles/2006/12/21/secrets-of-the-rails-console-ninjas">Secrets Of The Rails Console Ninjas</a>&#8221;.<br /><br />INSTALL<br /><br /><pre><code>sudo gem install utility_belt</code></pre><br />FEATURES<br /><ul><li>Interactively edit IRB code in your preferred text editor</li><br /><li>Read from and write to OS X clipboard</li><br /><li>Post your code to Pastie with one command (OS X only)</li><br /><li>Kick-ass Unix-style history buffer</li><br /><li>Write command history to file or vi</li><br /><li>Grep classes and methods for strings</li><br /><li>Verbosity controls for regular IRB and Rails console</li><br /><li>Finder shortcuts for Rails console</li><br /><li>Upload shortcut for Amazon S3</li><br /><li>Command-line Amazon S3 upload script</li><br /><li>Command-line Google shortcut (OS X only)</li><br /><li>Auto-indentation</li><br /><li><code>_</code> special variable (like Unix shell var !!)</li><br /><li>Extremely basic themes for Wirble syntax coloring</li><br /><li>Pascal/JavaScript-style &#8220;with&#8221; statement</li><br /><li><a href="http://raganwald.github.com/2007/10/stringtoproc.html">String#to_proc</a></li><br /><li>Grammatically-correct <code>is_an?</code> method - no more &#8220;<code>is_a? Array</code>&#8221; statements</li><br /><li>One-character exit command</li></ul><br /><hr><br /><br />Who can resist publicizing a grab-bag gem that just happens to contain some code you <a href="http://osteele.com/sources/javascript/functional/" title="Functional Javascript">snarfed from someone else</a>? Not me! It&#8217;s like one of those vanity books of poetry: your poem is included provided you buy twenty copies for your friends and family&#8230;<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://raganwald.github.com/archives/labels/ruby.html">ruby</a></p>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/utility-belt.html" title="permanent link">7:51 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			

			<div class="Post"><a name="7184744324849432039">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/somethings-fishy.html" title="permanent link">Something's Fishy (updated)</a></span>
					<div style="clear:both;"></div><strong>Part I: Continuums and False Dichotomies</strong><br /><br />On another of my posts, there were the following pair of comments:<br /><br /><blockquote>There are many people who do get into our field purely for money. The sad thing is that they&#8217;re allowed to. There are not enough sufficiently hard courses that weed out the less dedicated ones available on the university/college level. Same could be said of the HR people who are not able to distinguish wheat from chaff&hellip;</blockquote><div>&#8212;Srdjan</div><br /><blockquote>I don&#8217;t see why that&#8217;s necessarily a sad thing&#8230;The fact is that the majority of programming tasks aren&#8217;t actually that difficult. They don&#8217;t require a superstar in order to get done&#8230;</blockquote><div>&#8212;Guillaume<br/><font size="-1">(Please read Guillaume&rsquo;s  <a href="http://raganwald.github.com/2007/12/somethings-fishy.html#c6699414455785940672">clarification</a> below)</font></div><br />I agree that many programming tasks are not difficult. I am not convinced we have found a good way of predicting which tasks are difficult and which are not, which require a cut and a paste and which require some careful thought to avoid breaking something else or adding cruft to code.<br /><br />I don&rsquo;t think we do a very good job of dividing up work on a project such that the people with the least experience are protected from damaging the code. But that is just my opinion. I may be wrong.<br /><br />I am much more confident when I say that we have to be very careful when we set the bar for the minimum standard needed to ship software. The choice between (a) employing people who aren&rsquo;t particularly dedicated and would fail anything remotely resembling challenging courses in computer science and, (b) hiring &ldquo;superstars&rdquo; is a false dichotomy. There is such a thing as someone who is competent and professional enough to pass tough courses. Someone who won&rsquo;t get confused if you ask them to keep abreast of developments in their field.<br /><br />Guillaume <a href="http://raganwald.github.com/2007/12/somethings-fishy.html#c6699414455785940672">seems to agree</a>.<br /><br />In many other fields there are tough courses. MBA programs are often touted as separating the wheat from the chaff. Yet we don&rsquo;t assume that every MBA is a superstar in business. We do assume they have a baseline of competency. Likewise Chartered Accountants do not tolerate people taking a lukewarm attitude towards their field. But nobody would describe every accountant as a financial wizard.<br /><br />There&rsquo;s a continuum of talent, and we can raise the bar above the gutter without leaping from mediocre to world-class in a single bound.<br /><br />In any business situation, it&rsquo;s prudent to be wary of people who put their own selfish interests ahead of the business. So it&rsquo;s fine to avoid people who want to learn to use the latest bauble on your dime. But again, let&rsquo;s not establish another false dichotomy: people who are curious about programming and eager to learn are not automatically disinterested in shipping solid code using conservative strategies.<br /><br />The most important thing is to establish the baseline competency required for the job and find the people who meet it. We don&rsquo;t lower the bar to match whomever is available when we are looking, and we don&rsquo;t assume that our choices are always binary (Superstar vs. Mediocre, Passionate vs. Pragmatic, Java vs. Ruby).<br /><br /><strong>Part II: Something is still fishy</strong><br /><br /><div class="book"><hr><em><a id="lnx0" name="evtst|a|0201835959" href="http://www.amazon.com/gp/product/0201835959?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0201835959"><img src="http://raganwald.github.com/assets/images/old//mythical_man_month.jpg" border="0"></a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201835959" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1"><br><br>For a solid grounding on how to successfully develop software, start with <a name="evtst|a|0201835959" href="http://www.amazon.com/gp/product/0201835959?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0201835959">The Mythical Man-Month: Essays on Software Engineering</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0201835959" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1">. It is one of the most important books ever written about developing software, from the small to the large. Read the book that spawned the expression, â€œThere is no silver bullet.â€<br></em><hr></div>There is another way we can misinterpret Guillaume&rsquo;s comment. Many programming tasks are not difficult. True. But that does not mean that all programming tasks are not difficult. Furthermore, I have experienced a paradox: sometimes when a good person works on an easy task, they see things in the easy task that an average person would miss.<br /><br />An average person might copy and paste code all day. A good person might refactor to eliminate duplication. Of course, that means the good person can do far more of the easy work than the average person. But more importantly, the code base is forever improved, its friction has been lowered.<br /><br />The existence of easy tasks in programming can lead us to believe that a programming is a relatively unskilled trade. When we examine the pieces on their own, we might believe so. My question is this:<br /><br />If anyone can do it, <em>Why do we as an industry stink at it</em>? Although each piece seems easy, the whole of completing a successful project on time and budget with acceptable quality and good long-term cost of ownership is elusive.<br /><br />Now I know that Joel Spolsky and everyone else at Microsoft will tell you that software is ridiculously high quality compared to something-or-other. And with auto-widget-building wizards and AST-bending IDEs and memory management, today&#8217;s programmers ought to be ridiculously productive.<br /><br />But yet&#8230;<br /><br />I admit this is anecdotal, but I&#8217;m hearing a different story from my ex-colleagues and ex-clients out there: projects are late, bug lists are long and getting longer, and a lot of companies are scrutinizing their IT ROI and getting very Scrooge-like about starting new projects in-house.<br /><br />They just aren&#8217;t happy with the results they&#8217;re getting.<br /><br />Now maybe this has absolutely <em>nothing</em> to do with programmers. Maybe it&#8217;s all about requirements and waterfall and managing expectations. Maybe it&#8217;s all about looking at writing code and realizing that getting &rsquo;er done today with a few minor warts is more important than getting &rsquo;er done tomorrow with no bugs. (Or worse, tomorrow&#8217;s code is even buggier because it features an abstraction of a framework plugged into a component organized in a service architecture, and there&#8217;re so many moving parts that nothing works properly.)<br /><br />Or maybe this has nothing to do with the problem-solving, hold a complicated thing in your head, visualize all the ways it can go wrong so you can program defensively part of programming. I buy that. I buy that maybe we have to be better at writing programs for people to read. I buy that we have to be better at testing our code. I buy that we have to be better at all sorts of software development skills like analyzing requirements.<br /><br />It could be that programmers on the whole have all of the skills needed, and that our problem is we just haven&rsquo;t found the right formula for harnessing their power, for getting them all to march in lock step towards project success.<br /><br />Maybe we programmers are doing a <em>fine</em> job and there&#8217;s no need to be better at it. But somehow <em>something</em> isn&#8217;t right, and throwing more people with fewer skills at the problem doesn&#8217;t seem to be working.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/somethings-fishy.html" title="permanent link">4:05 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Friday, December 07, 2007</div>
			

			<div class="Post"><a name="7171925907865206482">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/amortized-costs-dos-and-magicicadas.html" title="permanent link">Amortized Costs, DOS, and Magicicadas</a></span>
					<div style="clear:both;"></div>Jeff Atwood has just posted an interesting article, <a href="http://www.codinghorror.com/blog/archives/001014.html">Hashtables, Pigeonholes, and Birthdays</a>. Hash Tables are a very interesting subject, you can take almost any aspect of them and follow it down interesting trails.<br /><br />For example:<br /><br /><em>Performance</em>: Quantifying the performance of a data structure like a Hash Table is interesting. There are measures like <em>Amortized Cost</em> as well as <em>Worst Case Cost</em>. This subject is one of the core themes of the book <a id="lnx1" name="evtst|a|0521663504" href="http://www.amazon.com/gp/product/0521663504?ie=UTF8&amp;tag=raganwald001-20&amp;link_code=as3&amp;camp=211189&amp;creative=373489&amp;creativeASIN=0521663504">Purely Functional Data Structures</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&amp;l=as2&amp;o=1&amp;a=0521663504" alt="" style="border: medium none  ! important; margin: 0px ! important;" border="0" height="1" width="1">. (You can also <a href="http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf" title="PDF of Purely Functional Data Structures, PhD thesis">download the author&#8217;s thesis on the same subject</a>) I recommend it whether you have an interest in &#8220;purely functional&#8221; programming or not: &#8220;purely functional&#8221; data structures provide all of the imperative and side-effect oriented operations you know and love&#8212;like insertions and removals&#8212;while also providing the foundations for highly concurrent environments like threads with shared memory.<br /><br /><em>Security</em>: One-way functions are strongly related to hash functions. They are the foundation for many of today&#8217;s security and secrecy protocols. For example, fingerprinting is used to allow mirror sites to host downloads while giving the public comfort that the downloads have not been compromised with Malware. However, if the one-way functions underlying them can be cracked&#8212;as MD5 was recently&#8212;miscreants can <a href="http://www.cits.rub.de/MD5Collisions/">substitute bad files for good</a> at will.<br /><br />Even when security does not appear to be a factor, compromising a hash function can have a security impact. As one person mentioned in one of Jeff&#8217;s comments, if the hash function for a programming language is public, attackers can deliberately engineer worst-case performance to create a Denial Of Service attack. Here&#8217;s a deliberately trivialized example:<br /><br />Consider a public-facing site with free user registration. When you log in, the site performs a look up on the user name. Now obviously there&#8217;s a database somewhere. But perhaps the programmers put a cache in front of it. You could imagine such a cache being useful if cookies are used to keep someone logged in. If the cache uses a hash table, a vandal can create lots and lots of user names that hash into the same bucket. Anyone with a user name in the same bucket will face a long wait as the system performs a serial look up within the bucket.<br /><br /><em>Whimsey</em>: One of the comments mentioned that the number of buckets is usually a prime number. Did you know that <a href="http://en.wikipedia.org/wiki/Magicicada" title="Magicicada - Wikipedia, the free encyclopedia">insects</a> figured this strategy out on their own?<br /><br /><hr/><br />Editorial/Love Fest:<br /><br />And now for what I really wanted to say.<br /><br />People have pointed out that Jeff often seems to be summarizing well-known computer science principles. A Reader&#8217;s Digest for programmers, as it were. The suggestion seems to be that this is not useful, since anybody with a degree or even a passing interest in programming ought to know these things. My own feeling is that Jeff&#8217;s blog is far more useful than my own.<br /><br /><a href="http://www.codinghorror.com/blog/">Coding Horror</a> is published out in the real world. It is written for real people.<br /><br />This weblog operates firmly in <a href="http://en.wikipedia.org/wiki/Lake_Wobegon_effect" title="Lake Wobegon effect - Wikipedia, the free encyclopedia">Lake Wobegon</a>. It&#8217;s true! The very fact that you are reading about programming means that you are exceptional for reading it and I am exceptional for writing it. I am not going to start a flame war and say you and I are <em>better programmers</em>. Who really knows? But I am very confident when I say that we are not <em>representative</em> of the typical programmer.<br /><br />The typical programmer does not know what a closure is and does not care. If they are added to Java he or she will not use them any ways. The typical programmer may have obtained their degree, but they were far more interested in memorizing whatever was needed to get a B on the examination then they were in the subject matter.<br /><br />They may have a certification, but they do not own and have not read books outside of their immediate requirements, so Knuth is foreign to them. While they may talk of refactoring, they have never heard of <a href="http://www.amazon.com/gp/product/0201485672?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0201485672">Martin Fowler</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0201485672" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> or <a href="http://www.amazon.com/gp/product/0321213351?ie=UTF8&tag=raganwald001-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321213351">Joshua Kerievsky</a><img src="http://www.assoc-amazon.com/e/ir?t=raganwald001-20&l=as2&o=1&a=0321213351" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />.<br /><br />When Jeff writes a Digg-able post about multiple monitors, or how to optimize memory on a Windows PC, he get readers that would never subscribe to a blog if they were told it was about programming. And I am talking about programmers. Try to wrap your head around the idea of programmers who do not find programming blogs interesting (in fact, they don&#8217;t find programming interesting at the moment).<br /><br />If they are then exposed to something insightful and interesting about hash tables&#8230; Many will read it and forget it, but a few will be interested enough to delve deeper into the whys behind the whats.<br /><br />I am all for that. It is remarkably easy to turn and preach to the choir. Evangelizing to the bored and uninterested&#8230; This is a frustrating and difficult job. I wish I had the zeal to reach out across the divide and bring people over to where programming is deeply fulfilling and fascinating. I&#8217;m glad Jeff is doing the job he&#8217;s doing and wish his blog every success.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/amortized-costs-dos-and-magicicadas.html" title="permanent link">10:36 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Wednesday, December 05, 2007</div>
			

			<div class="Post"><a name="81232781595763478">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/is-software-about-grades-or-ideas.html" title="permanent link">Is software about grades or ideas?</a></span>
					<div style="clear:both;"></div>Joel Spolsky yesterday:<br /><blockquote>The geeks want to solve the problem automatically, using software. They propose things like unit tests, test driven development, automated testing, dynamic logic and other ways to &#8220;prove&#8221; that a program is bug-free.<br />  <br />  The suits aren&#8217;t really aware of the problem. They couldn&#8217;t care less if the software is buggy, as long as people are buying it.</blockquote><br />And today:<br /><br /><blockquote>One of the reasons Schank hated undergrads so much was that they were obsessed with grades. He wanted to talk about whether computers could think and all undergrads wanted to talk about was why their paper got a B instead of an A.</blockquote><div>&#8212;Joel Spolsky, <a href="http://www.joelonsoftware.com/items/2007/12/05.html" title="Talk at Yale: Part 3 of 3 - Joel on Software">Talk at Yale</a></div><br /><hr/><br />Do I really have to expand this into an essay? How about this joke:<br /><br /><blockquote>A fellow is in Vegas to do some climbing at Red Rocks. He goes into a bar, it&#8217;s quiet, he leans over to the bartender. &#8220;Hey!&#8221; he calls out, &#8220;Wanna hear a joke about programmers?&#8221;<br />  <br />  The bartender frowns. &#8220;I&#8217;m a programmer,&#8221; the bartender says flatly. He points at a big guy playing pool in the corner, the guy looks like he twists re-bar into Christmas ornaments in his spare time. &#8220;Schank over there, he&#8217;s a computer science prof. And over there, Lois and Maude?&#8221; Our guy looks, there&#8217;re two women the size of tanks with the jar-head haircuts to match. &#8220;Lois and Maude are programmers, too.&#8221;<br />  <br />  The bartender leans forward menacingly. &#8220;Are you sure you want to tell us your little joke?&#8221;<br />  <br />  Our man finishes his drink, slaps down the money, and eases out off his stool. &#8220;No, best not to bother,&#8221; he says. The bartender nods. Our guy speaks again.<br />  <br />  &#8220;I hate it when I have to repeat the punch line.&#8221;</blockquote><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/is-software-about-grades-or-ideas.html" title="permanent link">12:32 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Monday, December 03, 2007</div>
			

			<div class="Post"><a name="3313690900406847019">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/thus-spake-joel.html" title="permanent link">Thus Spake Joel</a></span>
					<div style="clear:both;"></div><blockquote>What you&rsquo;ll see is that the hard-core geeks tend to give up on all kinds of useful measures of quality, and basically they get left with the only one they can prove mechanically, which is, <strong>does the program behave according to specification</strong>. And so we get a very narrow, geeky definition of quality: how closely does the program correspond to the spec. Does it produce the defined outputs given the defined inputs.<br />  <br />  The problem, here, is very fundamental. In order to mechanically prove that a program corresponds to some spec, the spec itself needs to be extremely detailed. In fact the spec has to define everything about the program, otherwise, nothing can be proven automatically and mechanically. Now, if the spec does define everything about how the program is going to behave, then, lo and behold, it contains all the information necessary to generate the program! And now certain geeks go off to a very dark place where they start thinking about automatically compiling specs into programs, and they start to think that they&rsquo;ve just invented a way to program computers without programming.<br />  <br />  Now, this is the software engineering equivalent of a perpetual motion machine. It&rsquo;s one of those things that crackpots keep trying to do, no matter how much you tell them it could never work. If the spec defines precisely what a program will do, with enough detail that it can be used to generate the program itself, this just begs the question: how do you write the spec? Such a complete spec is just as hard to write as the underlying computer program, because just as many details have to be answered by spec writer as the programmer. To use terminology from information theory: the spec needs just as many bits of <a href="http://en.wikipedia.org/wiki/Information_entropy" title="Information entropy - Wikipedia, the free encyclopedia">Shannon entropy</a> as the computer program itself would have. Each bit of entropy is a decision taken by the spec-writer or the programmer.<br />  <br />  So, the bottom line is that if there really were a mechanical way to prove things about the correctness of a program, all you&rsquo;d be able to prove is whether that program is identical to some other program that must contain the same amount of entropy as the first program, otherwise some of the behaviors are going to be undefined, and thus unproven. So now the spec writing is just as hard as writing a program, and all you&rsquo;ve done is moved one problem from over here to over there, and accomplished nothing whatsoever.</blockquote><div>&mdash;Joel Spolsky, <a href="http://www.joelonsoftware.com/items/2007/12/03.html" title="Talk at Yale: Part 1 of 3">Talk at Yale: Part 1</a></div><div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/thus-spake-joel.html" title="permanent link">3:25 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			
				<div class="DateHeader">Sunday, December 02, 2007</div>
			

			<div class="Post"><a name="7134922596659843997">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/does-your-employers-wilful-ignorance-of.html" title="permanent link">Does your employer's wilful ignorance of software development principles piss you off?</a></span>
					<div style="clear:both;"></div>Cut them a little slack, they aren&rsquo;t out to get you:<br /><blockquote>Any sufficiently advanced incompetence is indistinguishable from malice.</blockquote><div>&mdash;Greyâ€™s Law, via Daring Fireball</div><br />If you&rsquo;re still seething, you ought to know that <a href="http://mcommons.com/about/jobs">Mobile Commons is hiring</a>. We have <a href="http://mcommons.com/index.html">real products</a> being used by <a href="http://mcommons.com/customers.html">real customers</a>, and handle high transaction volumes in Ruby. In other words, we make practical magic.<br /><br />Care to join us?<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/does-your-employers-wilful-ignorance-of.html" title="permanent link">10:59 PM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		
			

			<div class="Post"><a name="5495414906803548589">&nbsp;</a>
				<span class="PostTitle">

					<a href="http://raganwald.github.com/2007/12/off-topic-whole-lotta-nuthin.html" title="permanent link">Off Topic: Whole Lotta Nuthin'</a></span>
					<div style="clear:both;"></div>For the first time in a <em>very</em> long time, I deleted a comment. (I delete the obvious spam all the time: &ldquo;Kewl Blog! Here's my blog about how to <a href="http://raganwald.github.com/2007/02/make-money-fast.html">Make Money Fast</a>&rdquo;). But this was just a garden-variety criticism.<br /><br />I forget the exact words, but I think they went along the lines of, &ldquo;You sure expanded a short quote into a lot of BS.&rdquo; And quite honestly, I had given my serenity the day off work. I was irritated. Very irritated.<br /><br />My feeling is that a certain kind of criticism is healthy. It indicates that the blog is putting out actual opinions and not just hand-waving.<br /><br />I can write a post about interviewing. If I don&rsquo;t want criticism, I can say things like, &ldquo;I review the candidate&rsquo;s track record and accomplishments with her, discussing her problem-solving approach and evaluating the cultural fit.&rdquo; Sounds great. Now, what did I say, exactly?<br /><br />Did I say, &ldquo;I don&rsquo;t hire her because she&rsquo;s a woman and our office is full of guys?&rdquo; Did I say, &ldquo;I hire her because she rails against cowboy coding, so I have a good feeling about her, even if I didn&rsquo;t actually find out if she can write any code herself?&rdquo; Nope, I didn&rsquo;t say anything you could point to.<br /><br />Compare and contrast that to talking about any <em>specific</em> question you ask in an interview. Whether you talk about a <a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">software design challenge</a> or <a href="http://raganwald.github.com/2007/03/thank-you-for-writing-such-heartfelt.html">an easy coding problem</a> to screen out people who can&rsquo;t actually program, someone will criticize you <em>because you have said something specific</em>. You can&rsquo;t even suggest asking a candidate <a href="http://raganwald.github.com/2007/05/icebreakers.html">how they got into the industry</a> without somebody suggesting you are using behavioral interviewing techniques and telling you how wrong that is.<br /><br />Criticism of ideas is a sign that you are actually putting out specific ideas, not just platitudes. And as an extra special bonus, those criticisms add value for everyone who reads the ideas.<br /><br />I recall <a href="http://www.zwitserloot.com/" title="Just grin and bear it...">Reiner Zwitserloot</a> saying that I just don&rsquo;t get it about static typing, that it is all about the tooling, not the safety. I really like that kind of opposition, it adds a lot of value for people reading the blog. It makes me re-examine my thoughts and convictions. I am grateful for that kind of feedback, even if it comes in a refreshingly frank form.<br /><br />However, the comment I deleted actually says nothing about the idea in the post. Well, it sort of says that I contributed nothing new, that I took a quote and added hot air. That is a kind of criticism, one that criticizes my writing style.<br /><br />But still, it says nothing about the underlying idea. This is not a blog about blogging. It is a blog about (at various times) career issues for software developers, software development, software, and most often, programming.<br /><br />Readers come here for those subjects. How does criticizing my lack of writing skill add value to their experience? If someone is reading a post and you point out that twenty paragraphs could have been one paragraph, how have you helped them decide whether that one paragraph is right, wrong, or <a href="http://en.wikipedia.org/wiki/Not_even_wrong">not even wrong</a>?<br /><br />I probably won&rsquo;t delete a comment like that if it comes up again. But I do want to encourage everyone to consider the other readers of this blog before commenting.<br /><br />Your comment is an opportunity to make the world a better place, to help someone else avoid the pitfalls and to steer them towards success. Don&rsquo;t squander that on criticisms that are way off-topic. Are my words full of BS? If so, take a moment to explain <em>why</em>.<div style="clear:both; padding-bottom:0.25em"></div>&nbsp;
					<span class="PostFooter">

						&para; <a href="http://raganwald.github.com/2007/12/off-topic-whole-lotta-nuthin.html" title="permanent link">10:20 AM</a>

					 
				</span> 


                                        <p id="postfeeds"></p>

			</div>

			

		


	</div>







	<div id="rightcontent">

		<div class="SideBarTitle"><a href="http://braythwayt.com">Reg Braithwaite</a></div>

		<br />

		<br />

		<div class="SideBarTitle">Recent Writing</div>

                <a href="http://homoiconic.com">Homoiconic</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Share</div>

                <a href="http://github.com/raganwald/rewrite_rails">rewrite_rails</a> /

                <a href="http://github.com/raganwald/andand">andand</a> /

                <a href="http://raganwald.com/assets/media/source/unfold.rb.html">unfold.rb</a> /

                <a href="http://raganwald.com/assets/media/source/string_to_proc.rb.html">string_to_proc.rb</a> /

                <a href="http://raganwald.com/assets/media/source/dsl_and_let.html">dsl_and_let.rb</a> /

                <a href="http://raganwald.com/assets/media/source/comprehensions.html">comprehension.rb</a> /

                <a href="http://raganwald.com/assets/media/source/lazy_lists.html">lazy_lists.rb</a>

		<br />

		<br />

		<div class="SideBarTitle">Beauty</div> <!-- idioms -->

		<a href="http://raganwald.github.com/2008/04/is-strictly-equivalent-to.html">IS-STRICTLY-EQUIVALENT-TO-A</a> /

		<a href="http://raganwald.github.com/2008/03/spaghetti-western-coding.html">Spaghetti-Western Coding</a> /

		<a href="http://raganwald.github.com/2007/12/golf-is-good-program-spoiled.html">Golf is a good program spoiled</a> /

		<a href="http://raganwald.github.com/2007/11/programming-conventions-as-signals.html">Programming conventions as signals</a> /

                <a href="http://raganwald.github.com/2007/10/too-much-of-good-thing-not-all.html">Not all functions should be object methods</a>

<br/><br/>

                <a href="http://raganwald.github.com/2007/05/not-so-big-software-application.html">The Not So Big Software Design</a> /

		<a href="http://raganwald.github.com/2007/04/writing-programs-for-people-to-read.html">Writing programs for people to read</a> /
                
		<a href="http://raganwald.github.com/2007/03/why-why-functional-programming-matters.html">Why Why Functional Programming Matters Matters</a> /

		<a href="http://raganwald.github.com/2007/02/but-y-would-i-want-to-do-thing-like.html">But Y would I want to do a thing like this?</a>

		<br />

		<br />

		<div class="SideBarTitle">Work</div>

                <a href="http://raganwald.github.com/2008/04/single-most-important-thing-you-must-do.html">The single most important thing you must do to improve your programming career</a> /

                <a href="http://raganwald.github.com/2008/02/naive-approach-to-hiring-people.html">The Na&iuml;ve Approach to Hiring People</a> /

                <a href="http://raganwald.github.com/2008/01/no-disrespect.html">No Disrespect</a> /

		<a href="http://raganwald.github.com/2006/11/take-control-of-your-interview.html">Take control of your interview</a> /

		<a href="http://raganwald.github.com/2006/08/three-tips-for-getting-job-through.html">Three tips for getting a job through a recruiter</a> /

		<a href="http://raganwald.github.com/2006/06/my-favourite-interview-question.html">My favourite interview question</a>

                <br/>

                <br/>



                <div class="SideBarTitle">Buy Raganwald a Coffee</div>
				
                       <div style="float: right; width: 64px; margin-left: 6px; font-style: italic; text-align: center; font-size: 80%;"><form name="DoubleEspresso" action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_donations">
<input type="hidden" name="business" value="raganwald@gmail.com">
<input type="hidden" name="item_name" value="Buy Raganwald a Darkhorse Double Espresso">
<input type="hidden" name="item_number" value="DoubleEspresso">
<input type="hidden" name="amount" value="3.15">
<input type="hidden" name="no_shipping" value="0">
<input type="hidden" name="logo_custom" value="http://raganwald.github.com/assets/images/old//coffeecup.png">
<input type="hidden" name="no_note" value="1">
<input type="hidden" name="currency_code" value="USD">
<input type="hidden" name="tax" value="0">
<input type="hidden" name="lc" value="CA">
<input type="hidden" name="bn" value="PP-DonationsBF">
<input type="image" src="http://raganwald.github.com/assets/images/old//coffeecup.png" width="64" height="64" border="0" name="submit" alt="Make payments with PayPal - it's fast, free and secure!">
<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form></div>If you enjoy reading my weblog, please consider <a href="#"
title="Buy Raganwald a darkhorse double espresso, for $3.15" onclick="javascript: document.DoubleEspresso.submit();">buying me a Darkhorse Double Espresso, for just $3.15</a>
                       Thank you!

		<br />

		<br />



		<div class="SideBarTitle">Management</div>

		<a href="http://raganwald.github.com/2008/02/exception-handling-in-software.html">Exception Handling in Software Development</a> /

		<a href="http://raganwald.github.com/2007/11/what-if-powerful-languages-and-idioms.html">What if powerful languages and idioms only work for small teams?</a> /

                <a href="http://raganwald.github.com/2007/08/bricks.html">Bricks</a> /

                <a href="http://raganwald.github.com/2007/06/which-theory-first-evidence.html">Which theory fits the evidence?</a> /

                <a href="http://raganwald.github.com/2007/06/still-failing-still-learning.html">Still failing, still learning</a> /

		<a href="http://raganwald.github.com/2005/01/what-ive-learned-from-failure.html">What I&rsquo;ve learned from failure</a>

		<br />

		<br />

		<div class="SideBarTitle">Notation</div> <!-- languages -->

		<a href="http://raganwald.github.com/2008/06/what-does-do-when-used-as-unary.html">The unary ampersand in Ruby</a> /

		<a href="http://raganwald.github.com/2008/02/1100inject.html">(1..100).inject(&amp;:+)</a> /

                <a href="http://raganwald.github.com/2007/10/challenge-of-teaching-yourself.html">The challenge of teaching yourself a programming language</a> /

                <a href="http://raganwald.github.com/2006/11/significance-of-meta-circular_22.html">The significance of the meta-circular interpreter</a> /
                
                <a href="http://raganwald.github.com/2007/08/block-structured-javascript.html">Block-Structured Javascript</a> /

                <a href="http://raganwald.github.com/2007/02/haskell-ruby-and-infinity.html">Haskell, Ruby and Infinity</a> /

		<a href="http://raganwald.github.com/2007/01/closures-and-higher-order-functions.html">Closures and Higher-Order Functions</a>

		<br />

		<br />

		<div class="SideBarTitle">Opinion</div>

		<a href="http://raganwald.github.com/2008/05/why-apple-is-more-expensive-than-amazon.html">Why Apple is more expensive than Amazon</a> /

		<a href="http://raganwald.github.com/2008/04/why-we-are-biggest-obstacle-to-our-own.html">Why we are the biggest obstacles to our own growth</a> /

		<a href="http://raganwald.github.com/2008/03/process-is-to-software-as-software-is.html">Is software the documentation of business process mistakes?</a> /

		<a href="http://raganwald.github.com/2007/09/we-have-lost-control-of-apparatus.html">We have lost control of the apparatus</a> /

		<a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html">What I&rsquo;ve Learned From Sales</a>
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-i.html" title="What I've Learned From Sales, Part I: Don't Feed the Trolls">I</a>, 
                <a href="http://raganwald.github.com/2007/01/what-ive-learned-from-sales-part-ii.html" title="What I've Learned from Sales, Part II: Wanna Bet?">II</a>, 
                <a href="http://raganwald.github.com/2007/10/how-to-use-blunt-instrument-to-sharpen.html" title="What I've Learned from Sales, Part III: How to use a blunt instrument to sharpen your saw">III</a>

		<br/>

		<br/>

		<div class="SideBarTitle">Whimsey</div>

                <a href="http://raganwald.github.com/2008/05/narcissism-of-small-code-differences.html">The Narcissism of Small Code Differences</a> /

		<a href="http://raganwald.github.com/2008/01/billy-martins-technique-for-managing.html">Billy Martin&rsquo;s Technique for Managing his Manager</a> /

		<a href="http://raganwald.github.com/2007/10/three-stories-about-tao.html">Three stories about The Tao</a> /

		<a href="http://raganwald.github.com/2007/02/programming-language-stories.html">Programming Language Stories</a> /

		<a href="http://raganwald.github.com/2005/07/why-you-need-degree-to-work-for-bigco.html">Why You Need a Degree to Work For BigCo</a>

		<br />

		<br />

		<div class="SideBarTitle">History</div>

		
			<a href="http://raganwald.github.com/archives/2004_06_01_archive.html">06/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_07_01_archive.html">07/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_08_01_archive.html">08/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_09_01_archive.html">09/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_10_01_archive.html">10/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_11_01_archive.html">11/04</a> /
		
			<a href="http://raganwald.github.com/archives/2004_12_01_archive.html">12/04</a> /
		
			<a href="http://raganwald.github.com/archives/2005_01_01_archive.html">01/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_02_01_archive.html">02/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_03_01_archive.html">03/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_04_01_archive.html">04/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_06_01_archive.html">06/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_07_01_archive.html">07/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_08_01_archive.html">08/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_09_01_archive.html">09/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_10_01_archive.html">10/05</a> /
		
			<a href="http://raganwald.github.com/archives/2005_11_01_archive.html">11/05</a> /
		
			<a href="http://raganwald.github.com/archives/2006_01_01_archive.html">01/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_02_01_archive.html">02/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_03_01_archive.html">03/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_04_01_archive.html">04/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_05_01_archive.html">05/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_06_01_archive.html">06/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_07_01_archive.html">07/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_08_01_archive.html">08/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_09_01_archive.html">09/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_10_01_archive.html">10/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_11_01_archive.html">11/06</a> /
		
			<a href="http://raganwald.github.com/archives/2006_12_01_archive.html">12/06</a> /
		
			<a href="http://raganwald.github.com/archives/2007_01_01_archive.html">01/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_02_01_archive.html">02/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_03_01_archive.html">03/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_04_01_archive.html">04/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_05_01_archive.html">05/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_06_01_archive.html">06/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_07_01_archive.html">07/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_08_01_archive.html">08/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_09_01_archive.html">09/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_10_01_archive.html">10/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_11_01_archive.html">11/07</a> /
		
			<a href="http://raganwald.github.com/archives/2007_12_01_archive.html">12/07</a> /
		
			<a href="http://raganwald.github.com/archives/2008_01_01_archive.html">01/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_02_01_archive.html">02/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_03_01_archive.html">03/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_04_01_archive.html">04/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_05_01_archive.html">05/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_06_01_archive.html">06/08</a> /
		
			<a href="http://raganwald.github.com/archives/2008_07_01_archive.html">07/08</a> /
		
		<script type="text/javascript" language="Javascript">if (location.href.indexOf("archive")!=-1) document.write("<strong><a href=\"http://raganwald.github.com/index.html\">Current Posts</a></strong>");</script>
		<br/></p>
		<br/>

		<p class="profile-link"><a href="http://feeds.raganwald.com/raganwald"><img src="http://feeds.raganwald.com/~fc/raganwald?bg=&amp;fg=&amp;anim=0" height="26" width="88" style="border: 0pt none ; vertical-align: middle;" alt="" /></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml"><img src="http://www.raganwald.com/fb/images/pub/feed-icon16x16.png" alt="" style="border: 0pt none ; vertical-align: middle;"></a>&nbsp;<a href="http://feeds.raganwald.com/raganwald" rel="alternate" type="application/rss+xml">Subscribe in a reader</a></p>

	</div>





	<div style="visibility: hidden">
		
		
		<script type="text/javascript" src="http://www.assoc-amazon.com/s/link-enhancer?tag=raganwald001-20">
		</script>
		<noscript>
			<img src="http://www.assoc-amazon.com/s/noscript?tag=raganwald001-20" alt="" />
		</noscript>
	</div>

</body>
</html>